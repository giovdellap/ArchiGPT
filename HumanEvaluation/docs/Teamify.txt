Teamify Project proposed by ArchiGPT-4o :

# CONTAINERS:

## CONTAINER NAME: user_authentication

### USER STORIES:
1) As a user, I want to create an account, so that I can use the application.
2) As a user, I want to login into the application, so that I can have access to my personal account within the application.
3) As a user, I want to logout from the application, so that I can leave the system without keeping my access credentials into the system.
6) As a user, I want to reset my password, so that I can login into the system even if I forget it.
7) As a user, I want to delete my account, so that my personal data will no longer be saved into the system.
### PORTS: 10000:10099
### DESCRIPTION: 
The user_authentication container is responsible for managing all user-related authentication processes within the Teamify application. Its core functions include account creation, which allows users to register and gain access to the system. Additionally, it handles user login, providing a gateway for users to access their personal accounts and utilize the application's features. Logout functionality ensures users can securely end their sessions, minimizing the risk of unauthorized access. The container also supports password reset capabilities, enabling users to recover access to their accounts if they forget their passwords. Finally, it allows users to delete their accounts, ensuring that users can control their personal data and remove it from the system as desired. This container is crucial for establishing user identity and maintaining security across the Teamify platform, making sure that all interactions and access points are adequately authenticated and authorized.
### PERSISTANCE EVALUATION
The user_authentication container needs to store data to fulfill its purpose and user stories. Specifically, it needs to store user credentials such as username and hashed passwords for account creation, login, and authentication processes. Additionally, it requires a mechanism to manage password reset tokens to securely confirm user identity before allowing password changes. Furthermore, account status data is necessary for managing account deletion requests, ensuring users' data can be effectively purged upon request.
### EXTERNAL SERVICES CONNECTIONS
The user_authentication container may benefit from connecting to external services to enhance its functionality. For instance, integrating with an external email service provider is recommended for sending password reset links to users. This connection would facilitate secure communication with users during account recovery processes. Additionally, integrating with third-party identity verification services can enhance account creation and login security, ensuring users' identities are verified through multiple steps.
### MICROSERVICES:
#### MICROSERVICE: account_management
- TYPE: backend
- DESCRIPTION: This microservice handles account creation, login, and logout operations. It manages user credentials, generates sessions, and ensures secure login/out. It interfaces with the database for validating login credentials, creating new user accounts, and managing session tokens. This microservice communicates with external services to verify user identity during account creation and sends notifications for password resets.
- PORTS: 10010
- TECHNOLOGICAL SPECIFICATION
The `account_management` microservice will be developed using NodeJS as the programming language due to its capability to handle asynchronous operations efficiently, which is crucial for managing user sessions and authentication workflows. It will utilize the Express framework for creating RESTful APIs that handle user authentication operations including account creation, login, and logout. For password encryption, the Bcrypt library will be used due to its robust hashing algorithm, ensuring passwords are securely stored. The `password_recovery` microservice can also follow a similar stack, using NodeJS and Express for API creation while leveraging Nodemailer or a similar library to facilitate email communication with external email service providers for password reset functionalities. The `account_deletion` microservice should maintain the same stack for consistency, utilizing Express for handling HTTP requests involved in validating user identity and executing deletion operations. The `authentication_database` will be based on a PostgreSQL database system, ensuring structured and reliable storage of user credentials and related session data.
- SERVICE ARCHITECTURE
The `account_management` service adopts a modular architecture pattern, separating concerns through distinct routing, controller, and service layers. The routing layer will handle incoming HTTP requests, delegating them to appropriate controllers which contain the main business logic for authentication operations. The controller interacts with the service layer, responsible for operations like token generation and validation, interfacing with the database layer for persistent storage access. Microservices are orchestrated using an event-driven architecture pattern; `password_recovery` and `account_deletion` services raise events on certain actions (like a password reset request or account deletion), allowing seamless communication and synchronization with the `account_management` service. The `authentication_database` service uses the repository pattern to abstract the database operations from the business logic, making it more maintainable and testable. Additionally, a facade pattern may be used to simplify interactions with external services, such as email dispatch and identity verification services, ensuring smooth integration without exposing any external complexities to the microservices themselves. This architectural choice enhances security and scalability while keeping the microservices self-contained and isolated in terms of responsibilities.
- ENDPOINTS
HTTP Method	Endpoint URL	Description	User Stories
POST	/account_management/register	Register a new user account, allowing access to the Teamify application	1
POST	/account_management/login	Authenticate a registered user and provide access to their personal account within the application	2
POST	/account_management/logout	Log the user out from the application, invalidating the current session	3
POST	/password_recovery/request	Initiate a password reset request and send a password reset link to the user's email	6
POST	/password_recovery/reset	Reset a user's password using a valid token, allowing them to regain access to their account	6
DELETE	/account_deletion/delete	Permanently remove a user's account and all associated data from the Teamify application	7

#### MICROSERVICE: password_recovery
- TYPE: backend
- DESCRIPTION: This microservice supports password reset functionality. It generates secure tokens for password reset requests and verifies these tokens before allowing password changes. It also sends password reset emails via an integrated email service. Ensures secure recovery of user access.
- PORTS: 10020
- TECHNOLOGICAL SPECIFICATION
The password_recovery microservice will use Python as the primary programming language, leveraging the Flask framework to facilitate the creation of RESTful APIs. Flask is chosen due to its lightweight nature and flexibility, which makes it suitable for handling authentication workflows. For secure token generation and management, the `itsdangerous` library will be used, which provides capabilities for securely signing data with a key. Additionally, the `smtplib` library from Python's standard library will be utilized to enable email integration, allowing the microservice to send reset links through an SMTP server.
- SERVICE ARCHITECTURE
The service architecture for the password_recovery microservice will implement a clear division of responsibilities using a model-view-controller (MVC) pattern. The model component will handle the logic for generating and verifying password reset tokens. The view will be responsible for defining the RESTful API endpoints used by the service, such as endpoints for initiating a password reset and verifying reset tokens. The controller will serve as an intermediary, coordinating actions between the model and the view, especially on token validation requests. The service will also include a service layer connecting to the external email provider for sending out reset notifications, using an adapter pattern to facilitate interaction with various email services if needed.
- ENDPOINTS
HTTP Method	Endpoint URL	Description	User Stories
POST	/password-recovery/request	Initiate a password recovery process, generating and sending a secure reset token to the user's registered email address.	6
POST	/password-recovery/verify	Verify the provided password reset token to ensure its validity and allow the user to proceed with the password change.	6
POST	/password-recovery/reset	Allow the user to set a new password upon successful verification of the reset token, updating their credentials in the system.	6

#### MICROSERVICE: account_deletion
- TYPE: backend
- DESCRIPTION: Responsible for handling user account deletion requests. It validates user identity and securely deletes user data from the system. Ensures compliance with data protection regulations by purging account-related information.
- PORTS: 10030
- TECHNOLOGICAL SPECIFICATION
The account_deletion microservice will be developed using Python as the primary programming language. The Flask framework will be utilized for building RESTful APIs due to its lightweight and flexible nature. For data validation and serialization of request/response objects, the Marshmallow library will be used. To handle identity verification and secure data deletion, the library Flask-JWT-Extended will be adopted to manage JSON Web Tokens (JWT) for token-based authentication. Additionally, its operations may involve communication with external identity verification services, for which the requests library will facilitate HTTP requests.
- SERVICE ARCHITECTURE
The account_deletion microservice follows a modular architecture with a distinct separation of concerns. It adopts a service-oriented pattern where the service is split into layers consisting of routes, controllers, and services. The routes layer manages HTTP request endpoints, the controllers handle business logic, including validation of user identities before deletion, and the services layer interacts with the database to execute secure data deletion. The microservice uses an event-driven architecture for data deletion, triggering events whenever account deletions occur to ensure audit logging and compliance with data protection regulations. This separation ensures that the microservice is scalable and maintainable, efficiently handling account deletion requests while adhering to security protocols.
- ENDPOINTS
HTTP Method	Endpoint URL	Description	User Stories
DELETE	/account_deletion/delete_account	Validate the user's identity and securely delete their account and associated data from the system, ensuring compliance with data protection regulations. Triggers events for audit logging.	7

#### MICROSERVICE: authentication_database
- TYPE: database
- DESCRIPTION: This microservice stores user credentials, including usernames, hashed passwords, and session data. It stores tokens required for password resets and other authentication-related data, providing persistent storage needed by the user_authentication container's backend services.
- PORTS: 10040


## CONTAINER NAME: user_profile

### USER STORIES:
4) As a user, I want to visualize my personal information, so that I can check whether they are correct or not.
5) As a user, I want to modify my personal information, so that I can change my password or whatever other information that is not correct at any time.
### PORTS: 10100:10199

### DESCRIPTION: 
The user_profile container is responsible for managing the visualization and modification of user profile information in the Teamify application. Its main purpose is to allow users to access and update their personal information related to their profiles. The container serves two primary user stories: first, enabling users to view their personal information to ensure its accuracy, and second, allowing users to modify this information as needed. This can include updates to personal details, such as passwords or any incorrect information. By handling these user interactions, the user_profile container ensures that individuals can maintain accurate and up-to-date information within the system, thus enhancing their overall user experience.

### PERSISTANCE EVALUATION
The user_profile container needs to store user data in order to fulfill its purpose and user stories. This data includes personal information such as names, email addresses, and possibly other details the user can update through the system. Additionally, it must manage versions of user profile data to handle updates and modifications effectively. The container may also need to store audit logs or history of changes for security and traceability purposes, particularly when users update sensitive information like passwords.

### EXTERNAL SERVICES CONNECTIONS
Based on the container's purpose and user stories, there is no explicit need for the container to connect to external services. However, if Teamify offers federated identity or integrates with third-party identity providers (e.g., OAuth or social logins), it may connect to external authentication services for accessing updated user profile information. Additionally, if any external data sources provide user-related information (e.g., profile pictures from social networks), connections to these services would be necessary to enhance the user profile functionalities.

### MICROSERVICES:

#### MICROSERVICE: profile_view
- TYPE: backend
- DESCRIPTION: The microservice allows users to visualize their personal information stored within the system. It provides endpoints for retrieving user profile data such as names, email addresses, and other personal details. This allows the user to verify their stored information's accuracy.
- PORTS: 10110
- TECHNOLOGICAL SPECIFICATION
The profile_view and profile_update microservices, being part of the backend, will utilize NodeJS as their programming language due to its popularity and efficiency in handling I/O operations for microservices. Express.js will serve as the web application framework to facilitate the creation of RESTful APIs. For the profile_update microservice, additional libraries like Joi can be used for input validation to ensure data integrity and security. The profile_storage microservice requires a robust database system, and PostgreSQL is an ideal choice due to its strong emphasis on data integrity, which is important for handling user information and audit logs. The `pg` library should be utilized to interface with PostgreSQL from within NodeJS applications.
- SERVICE ARCHITECTURE
The service architecture adopts the microservices pattern by splitting functionalities into distinct services, each with its own focused responsibility. Each microservice will be containerized using Docker, allowing them to be independently deployable and scalable. The profile_view and profile_update microservices will implement a layered architecture pattern where routes will be defined to handle HTTP requests. The incoming requests will be processed by controller functions before interacting with a repository layer that communicates with the profile_storage microservice. This structure ensures clean separation of concerns and facilitates maintainability and scalability. The profile_storage microservice will implement a repository pattern to encapsulate all database interactions, reinforcing data integrity and enabling easy auditing by tracking changes and maintaining data history.
- ENDPOINTS
HTTP Method	Endpoint URL	Description	User Stories
GET	/profile_view/personal_info	Retrieve and display user's personal information, such as names and email addresses, allowing users to verify the accuracy of their stored data.	4
PUT	/profile_update/personal_info	Update the user's personal information, enabling modifications to their details, such as email or password changes, ensuring data integrity and maintaining audit logs.	5

#### MICROSERVICE: profile_update
- TYPE: backend
- DESCRIPTION: The microservice facilitates the modification of user's personal information. It provides endpoints for updating the user's details, such as email, password, and other profile attributes. It ensures that updates are correctly managed and stored, maintaining data integrity and audit logs as necessary.
- PORTS: 10120
- TECHNOLOGICAL SPECIFICATION
For the `profile_update` microservice, the proposed technological stack should include a backend language suitable for handling HTTP requests and data processing related to user profiles. A popular choice in this domain is Node.js due to its non-blocking architecture and efficiency in building scalable network applications. Utilizing the Express framework with Node.js would be beneficial for creating RESTful APIs. Additionally, incorporating libraries such as Joi for data validation and bcrypt for password hashing is necessary to ensure data quality and security.
- SERVICE ARCHITECTURE
The `profile_update` service should adopt a layered architecture pattern to separate concerns effectively. The architecture should include the following layers:
1. **Presentation Layer**: This is responsible for handling incoming HTTP requests, using a routing mechanism to direct the requests to the appropriate handlers.
2. **Application Layer**: This contains the business logic for updating profiles. It should include controllers that manage the flow of requests, orchestrating calls to the service layer and ensuring that business rules are adhered to.
3. **Service Layer**: A set of independent service functions that encapsulate business logic related to the modification of user profiles. These services communicate with the data access layer to perform CRUD operations.
4. **Data Access Layer**: This layer interacts with the `profile_storage` microservice to retrieve and update user profile information within the database. It should include a data mapper or repository pattern for abstracting the database interactions.
5. **Logging and Audit**: Implement a logging mechanism to track the changes to user profiles and maintain audit trails for modifications, focusing on sensitive information.
The service will also focus on transaction management to ensure all changes to profiles are atomic and maintain integrity. It would also be beneficial to implement a microservices-related pattern such as the Circuit Breaker, to handle failures when communicating with `profile_storage`, hence increasing the resilience of the system.
- ENDPOINTS
HTTP Method	Endpoint URL	Description	User Stories
GET	/profile/view	Retrieves and returns the personal information of the currently authenticated user to allow verification of stored data accuracy.	4
PUT	/profile/update	Updates the personal information of the user, such as email, password, and other modifiable attributes, ensuring data integrity and proper logging.	5

#### MICROSERVICE: profile_storage
- TYPE: database
- DESCRIPTION: The microservice ensures data persistence for user profiles, storing details like names, email addresses, and other modifiable information. It also manages audit logs and potentially the history of updates for traceability and security purposes.
- PORTS: 10130

## CONTAINER NAME: notifications

### USER STORIES:
8) As a user, I want to have access to the notification section, so that I can see all the notifications that have been sent to me.
### PORTS: 10200:10299

### DESCRIPTION: 
The "notifications" container is responsible for managing and delivering real-time notifications to users within the Teamify application. It serves the crucial purpose of ensuring users receive timely updates about events, tasks, messages, or any other relevant activities that occur within the application. This container plays a key role in enhancing user engagement by making sure users are instantly informed of any changes or actions they need to be aware of. The user story associated with this container highlights the user's need to access a dedicated section where all their notifications are aggregated and can be easily viewed. By providing this functionality, the notifications container helps users stay organized and responsive, ultimately contributing to the efficiency and effectiveness promised by Teamify's collaborative environment.

### PERSISTANCE EVALUATION
The "notifications" container requires persisting data to ensure users have access to their notifications history. To fulfill the user story associated with viewing notifications, the container needs to store data related to the notifications themselves. This includes information such as the notification ID, type, content, timestamp, recipient user ID, and possibly a status indicating whether the notification has been read or not. By storing this data, the container ensures that users can access a complete and organized view of their notifications, even if they reconnect to the system after being inactive for a while.

### EXTERNAL SERVICES CONNECTIONS
Based on the purpose and user story for the "notifications" container, there is no inherent need to connect to external services. Notifications are primarily generated from within the Teamify application, and the container is designed to manage and deliver these notifications internally. Thus, it doesn't rely on third-party APIs or external services for its core functionality of delivering real-time notifications to users.

### MICROSERVICES:

#### MICROSERVICE: notification_manager
- TYPE: backend
- DESCRIPTION: This microservice handles the generation and delivery of real-time notifications to the users within the Teamify application. It processes events from various components within the system to create appropriate notifications and ensure users receive timely updates. It also manages notification statuses, like read or unread, and stores notification history for users to view at any time.
- PORTS: 10210
- TECHNOLOGICAL SPECIFICATION
The main programming language for the `notification_manager` microservice is Python. The Flask framework will be employed to set up the RESTful API endpoints necessary for generating and delivering notifications. To facilitate real-time notification delivery, libraries such as Flask-SocketIO will be utilized for WebSocket communication. Additionally, SQLAlchemy will be used as the Object Relational Mapping (ORM) tool to interact with the notification_storage database.
- SERVICE ARCHITECTURE
The `notification_manager` service architecture adopts the event-driven pattern. It listens for events emitted by various components of the Teamify application. When an event occurs, the service creates a notification based on the event's details and user preferences. The service communicates with the `notification_storage` microservice to store, update, and retrieve notification data. Additionally, the service ensures real-time delivery by leveraging WebSocket connections for instantaneous push notifications, maintaining a persistent state with updates through HTTP requests for fetching historical data.
- ENDPOINTS
HTTP Method	Endpoint URL	Description	User Stories
POST	/notifications/send	Create and send a notification based on a particular event within the Teamify application, ensuring users receive real-time updates.	8
GET	/notifications	Retrieve the complete list of notifications for the user, including details like notification content, timestamp, and read status.	8
PATCH	/notifications/mark-as-read	Update the status of specific notifications to 'read', enabling users to manage notification statuses and maintain an organized view.	8
GET	/notifications/unread-count	Fetch the count of unread notifications for a user to provide a quick overview of pending notifications.	8

#### MICROSERVICE: notification_storage
- TYPE: database
- DESCRIPTION: This microservice is responsible for storing all notification-related data, including notification ID, type, content, timestamp, recipient user ID, and status. It ensures the persistent storage and retrieval of notification history so users can access their notifications even after periods of inactivity.
- PORTS: 10220

## CONTAINER NAME: personal_tasks

### USER STORIES:
9) As a user, I want to visualize my personal agenda, so that I can check at any time which are my personal tasks.
11) As a user, I want to create a personal task, so that I can better organize my personal life.
12) As a user, I want to modify a personal task, so that I can adjust some incorrect things that I have specified before.
13) As a user, I want to delete a personal task, so that I can empty a time slot of my personal agenda.
14) As a user, I want to check a personal task for completion, so that I can see which are the remaining personal tasks to do and which are those that I have already completed.
### PORTS: 10300:10399

### DESCRIPTION: 
The "personal_tasks" container is dedicated to managing individual task-related functionalities in the Teamify application. It enables users to efficiently organize and oversee their personal agendas by providing the ability to create, view, modify, delete, and mark tasks as complete. This container supports the user's need to have a clear and accessible list of personal tasks, helping them manage their time and responsibilities effectively. Through its operations, users can create new tasks to better organize their personal life, adjust previously defined tasks to correct any details, remove tasks to free up time slots, and mark tasks as completed to keep track of progress. This container encapsulates all necessary backend processes related to personal task management, allowing for a seamless and user-friendly experience when dealing with personal tasks within the application.

### PERSISTANCE EVALUATION
The "personal_tasks" container requires data storage to manage and facilitate user interactions with personal tasks. It needs to store data related to individual tasks, such as task descriptions, deadlines, statuses (e.g., completed or pending), and any associated metadata, such as priority levels or categories. This is necessary to fulfill user stories related to creating, visualizing, modifying, deleting, and marking tasks as complete, enabling users to manage their personal agendas efficiently.

### EXTERNAL SERVICES CONNECTIONS
Based on the container's purpose and user stories, the "personal_tasks" container does not inherently require connections to external services. Its functionalities are focused on managing tasks directly within the Teamify system, as described in the user stories.

### MICROSERVICES:

#### MICROSERVICE: task_management
- TYPE: backend
- DESCRIPTION: Handles all backend processes related to personal task management, including creating, modifying, deleting, and marking tasks as completed. It manages user interactions and data processing for personal task agenda, ensuring users can efficiently organize and oversee their personal tasks.
- PORTS: 10310
- TECHNOLOGICAL SPECIFICATION
The "task_management" microservice, being a backend service, will utilize Python as its main programming language to leverage its robust set of libraries and frameworks for web service development. Flask will be used as the main web framework to build RESTful APIs, due to its lightweight nature and ease of creating expandable APIs for handling task-related functionalities. For database connectivity and ORM, SQLAlchemy will be used to integrate seamlessly with the task_storage service for data persistence. Auxiliary libraries such as Marshmallow for data serialization and validation and Celery for managing asynchronous task queues may also be included if needed to manage large sets of task operations or for deferred task processing.
- SERVICE ARCHITECTURE
The architecture of the "task_management" service will follow the Model-View-Controller (MVC) pattern, which will ensure clear separation of concerns across the service.
- **Model**: SQLAlchemy models will define and interact with the task data elements stored in the "task_storage" database service, capturing all details such as descriptions, deadlines, statuses, priority levels, and categories.
- **View**: Flask's routing will serve as the view layer, handling HTTP requests from the client and routing them to the appropriate controller functions based on user actions.
- **Controller**: The service will house a set of controllers responsible for processing user requests, containing the logic for task creation, modification, deletion, and status updates. These controllers will interact with the model layer for CRUD operations
Furthermore, the service will incorporate a Repository or Data Access Layer to abstract the database interactions, providing an encapsulated and modular approach to handle task data persistence. This pattern ensures that data management logic is separated from business logic, promoting a clean code structure that enhances maintainability and allows for easier scaling of the service's functionalities.
- ENDPOINTS
HTTP Method	Endpoint URL	Description	User Stories
GET	/tasks	Retrieve and display a list of the user's personal tasks, allowing for an overview of pending and completed tasks	9
POST	/tasks	Create a new personal task using provided details, helping users organize their personal agendas	11
PUT	/tasks/{taskId}	Update an existing personal task's details, allowing users to correct mistakes or make adjustments	12
DELETE	/tasks/{taskId}	Remove a personal task from the user's agenda, freeing up time slots and reducing clutter	13
PATCH	/tasks/{taskId}/complete	Mark a personal task as complete, helping users track their progress and identify remaining tasks	14

#### MICROSERVICE: task_storage
- TYPE: database
- DESCRIPTION: Responsible for storing data related to individual tasks, such as task descriptions, deadlines, statuses, priority levels, and categories. It ensures persistence of all task-related information to support personal task management functionalities
- PORTS: 10320


## CONTAINER NAME: team_management

### USER STORIES:
15) As a user, I want to create a team, so that I can have a shared agenda with my colleagues.
16) As a user, I want to join an existing team, so that I can receive notifications about events from my colleagues.
17) As a user, I want to visualize the list of all the teams I have joined so far, so that I can see all their details.
18) As a team member, I want to leave a team which I belong to, so that I will receive no more notifications from people that are no longer my colleagues.
19) As a team administrator, I want to select other team members to be administrators as well, so that I can more easily manage the team.
20) As a team administrator, I want to select other team administrators not to be administrators anymore, so that I can more easily manage the team.
25) As a team administrator, I want to edit team's information, so that I can change whatever information that is not correct at any time.
26) As a team administrator, I want to delete a team, so that I can remove a team that is no longer necessary.
### PORTS: 10400:10499

### DESCRIPTION: 
The team_management container is designed to facilitate team-oriented functionalities within the Teamify application. This container handles the creation and management of teams, including inviting members to join teams, listing all teams a user is part of, and allowing team members to leave teams. It also provides functionality for team administrators to manage team roles, including assigning or revoking administrator privileges to other team members, and editing team information. Additionally, the team_management container allows administrators to delete teams that are no longer needed. Essentially, this container serves as the core of the application's team collaboration feature, enabling efficient team management and collaboration. This container operates on ports 10400 through 10499.

### PERSISTANCE EVALUATION
The team_management container requires storing various data to fulfill its purpose and user stories. It needs to store information about teams, such as team names, descriptions, creation dates, and status (active or deleted). Additionally, it must store lists of team members, including their roles and privileges, such as administrator status. The container must also record invitations to join teams, including pending and accepted statuses. Furthermore, user actions within teams, such as joining, leaving, and changes in roles, need to be tracked for audit and management purposes.

### EXTERNAL SERVICES CONNECTIONS
Based on the container's purpose and user stories, there does not appear to be a need for the team_management container to connect to external services. All functionalities such as team creation, member management, and administrator role assignments can be handled within the application without relying on third-party services. All necessary data interactions can be performed internally within the Teamify ecosystem.

### MICROSERVICES:

#### MICROSERVICE: team_manager
- TYPE: backend
- DESCRIPTION: This microservice manages all core functionalities related to teams, such as creating and deleting teams, inviting and managing team members, and assigning or revoking administrator privileges. It also allows team members to leave teams and facilitates editing of team information.
- PORTS: 10410
- TECHNOLOGICAL SPECIFICATION
The `team_manager` microservice uses Java as its core programming language due to its robust handling of concurrent connections and ease of integration with various persistence solutions. The Spring Boot framework is chosen to facilitate the development of RESTful services and to take advantage of its dependency management and project structure conventions. Hibernate ORM is used for managing data storage interactions in a relational database, enabling efficient mapping of team roles, member details, and other team-related entities. For in-memory data and caching during runtime, Redis is recommended to optimize frequent data accesses and manage sessions effectively.
- SERVICE ARCHITECTURE
The service architecture adopts a layered pattern, with clear separation of responsibilities across each layer. The presentation layer comprises RESTful controllers powered by Spring MVC, handling incoming HTTP request routing. The business logic layer contains service classes that implement the core functionalities of the team management logic, including team creation, member management, and role assignments. The persistence layer employs repositories that leverage Spring Data JPA and Hibernate for seamless database interactions. Furthermore, the service architecture integrates a Command Query Responsibility Segregation (CQRS) pattern to efficiently separate read and write operations for smoother performance and scalability. Additionally, the architecture uses a transactional pattern to maintain data consistency during operations that alter team and member data.
- ENDPOINTS
HTTP Method	Endpoint URL	Description	User Stories
POST	/team_manager/create	Create a new team with the provided information, enabling users to collaborate and share an agenda	15
POST	/team_manager/join	Allow a user to join an existing team, facilitating notifications about events from team members	16
GET	/team_manager/list	Retrieve a list of all teams a user is a part of, displaying detailed information for each team	17
POST	/team_manager/leave	Enable a team member to leave a team, stopping notifications from that team	18
POST	/team_manager/assign_admin	Assign administrator privileges to another team member to assist in managing the team	19
POST	/team_manager/revoke_admin	Revoke administrator privileges from a team member to streamline team management	20
PUT	/team_manager/edit	Edit and update team information to correct or change existing details	25
DELETE	/team_manager/delete	Delete a team that is no longer necessary, removing it from the system	26

#### MICROSERVICE: team_storage
- TYPE: database
- DESCRIPTION: This microservice is responsible for storing and managing data related to teams, including team details, member details, roles, invitations, and audit logs of team activities.
- PORTS: 10420


## CONTAINER NAME: team_events

### USER STORIES:
10) As a team member, I want to visualize the agenda that is shared between me and a specific team which I belong to, so that I can check at any time which are the events shared with that team.
27) As a team administrator, I want to create an event, so that I can share a task with the colleagues belonging to a specific team which I am managing.
28) As a user, I want to accept or refuse the invitation to participate at an event, so that I can communicate my decision to the team administrator.
29) As a team administrator, I want to modify an event, so that I can adjust some incorrect things that I have specified before.
30) As a team administrator, I want to delete an event, so that I can empty a time slot of the entire team’s shared agenda.
31) As a team administrator, I want to check an event for completion, so that I can see which are the remaining shared tasks to do and which are those that we have already completed.
### PORTS: 10500:10599

### DESCRIPTION: 
The team_events container is designed to manage events within teams. Its primary responsibilities include the creation, modification, deletion, and completion tracking of team events. This container facilitates the shared agenda functionality, allowing team members to visualize events specific to their team. As various team roles participate, it handles input from administrators for event management tasks such as creating new events, modifying existing ones, ensuring they align with team needs, and marking events as complete. Furthermore, it supports decision-making around event participation by enabling users to accept or decline event invitations, thereby communicating their attendance to team administrators. Overall, the team_events container plays a crucial role in organizing and streamlining team schedules, ensuring effective coordination and collaboration within teams on the platform.

### PERSISTANCE EVALUATION
The team_events container requires data storage to manage the creation, visualization, modification, deletion, and completion status of team events. It should store information such as event details (e.g., title, description, date, time, and location), team association, participant list, invitation statuses (accepted or declined), and completion status. Additionally, it should maintain historical data for auditing and reference purposes. This ensures that team events are accurately tracked and managed over time, enabling users to effectively organize and coordinate their team schedules.

### EXTERNAL SERVICES CONNECTIONS
Based on the purpose and user stories associated with the team_events container, there is no immediate need for external service connections. However, if features such as calendar synchronization (e.g., Google Calendar, Microsoft Outlook) or integration with third-party scheduling tools are desired in the future, external API connections may be required to facilitate such functionalities. For now, the container can operate independently within the Teamify ecosystem without dependencies on external services.

### MICROSERVICES:

#### MICROSERVICE: event_manager
- TYPE: backend
- DESCRIPTION: This microservice is responsible for handling the creation, modification, deletion, and completion tracking of team events. It manages user requests to create new events, modify existing ones, and mark them as complete. Additionally, it allows users to accept or decline invitations to events, and it communicates these decisions to the team administrators.
- PORTS: 10510
- TECHNOLOGICAL SPECIFICATION
The `event_manager` microservice utilizes Python as its main programming language, with Django Rest Framework (DRF) as the primary framework to build RESTful APIs, handling the backend logic for event management. To complement the DRF functionality, the service uses Celery for asynchronous task management, especially valuable for handling potentially long-running tasks like event updates or communication. The microservice also uses PostgreSQL as its database, which will interact with the `event_storage` microservice for persistent storage solutions.
- SERVICE ARCHITECTURE
The `event_manager` service architecture adopts a modular pattern emphasizing layered architecture. The service is divided into numerous components that include:
- **API Layer**: The API layer exposes RESTful endpoints that process requests and responses. DRF's serializers and viewsets will be used to easily translate requests into Python objects and vice versa.
- **Business Logic Layer**: This layer will manage the core logic of event management, including methods for creating, modifying, deleting, and tracking the completion of events. The layer also handles user interactions such as accepting or declining invitations.
- **Data Access Layer**: This layer interfaces with the `event_storage` microservice to perform CRUD operations on database records. It ensures proper data handling and communication with the database.
- **Background Task Layer**: With Celery, the service can handle asynchronous operations, such as sending notifications to team administrators or participants when event changes occur.
By structuring the service in layers and employing these patterns, the architecture ensures separation of concerns, scalability, and robustness.
- ENDPOINTS
HTTP Method	Endpoint URL	Description	User Stories
GET	/events	Retrieve and return a list of all events for a specific team, allowing team members to visualize shared agenda	10
POST	/events	Create a new event with specified details by a team administrator to share tasks with team members	27
PATCH	/events/{event_id}	Modify details of an existing event by a team administrator to correct or adjust event information	29
DELETE	/events/{event_id}	Delete an event by a team administrator to remove it from the team’s shared agenda	30
POST	/events/{event_id}/complete	Mark an event as complete by a team administrator, indicating the task is finished	31
POST	/events/{event_id}/respond	Accept or decline an event invitation to communicate user's participation decision to the team administrator	28

#### MICROSERVICE: event_storage
- TYPE: database
- DESCRIPTION: This microservice manages the persistent storage of team events data. It stores detailed information about each event, including the title, description, date, time, location, team association, participant list, invitation statuses, and completion status. It also maintains historical data for auditing and reference purposes.
- PORTS: 10520

#### MICROSERVICE: agenda_visualizer
- TYPE: frontend
- DESCRIPTION: This microservice provides a user interface for displaying the shared agenda of team events. It allows team members to visualize events specific to their team and offers interfaces for users to interact with their event invitations and statuses.
- PORTS: 10530
- TECHNOLOGICAL SPECIFICATION
The microservice "agenda_visualizer" uses ReactJS as its primary technology stack due to its efficiency in creating user interfaces and its component-based architecture which allows for reusable UI components. Along with ReactJS, it employs Redux for state management to efficiently manage and respond to user interactions and data changes in the shared agenda visualization. For styling, the service utilizes Styled Components or CSS Modules to ensure modular and maintainable styles across components. Additional libraries such as Axios can be used for making HTTP requests to backend services, particularly the "event_manager" microservice.
- SERVICE ARCHITECTURE
The service follows a component-based architecture, essential for frontend services, where the UI is broken down into smaller, reusable components responsible for rendering individual parts of the user interface, such as event lists, calendars, and invitation status displays. It employs the Flux pattern via Redux for state management to streamline data flow, where the central store holds the entire state of the application, and the view components subscribe to relevant parts of this state. The integration with backend services relies on RESTful API endpoints provided by the "event_manager" microservice. The UI components dispatch actions that trigger changes in the Redux store based on the user interactions and backend responses. Data fetching and updates are handled in an asynchronous manner using Redux Thunk or Redux Saga to manage side effects such as API requests, ensuring the application remains responsive and maintains a consistent state across user interactions.
- PAGES
Page Name	Description	User Stories
Team Agenda	Displays the shared agenda of team events, allowing team members to visualize events specific to their team.	10
Event Creation	Interface for team administrators to create new events for their team.	27
Event Management	Facilitates modification, deletion, and completion tracking of team events.	29, 30, 31
Event Invitations	Allows users to accept or decline invitations to events, communicating their decision to team administrators.	28


## CONTAINER NAME: messaging
### USER STORIES:
21) As a team member, I want to send messages in a group chat, so that I can easily communicate with all the other team members.
### PORTS: 10600:10699

### DESCRIPTION: 
The messaging container is dedicated to facilitating real-time chat functionalities within teams. Its primary function is to enable seamless communication among team members through a group chat interface. By addressing the user story, "As a team member, I want to send messages in a group chat, so that I can easily communicate with all the other team members," this container ensures that users can send and receive messages instantly, enhancing team collaboration and communication. The messaging service might employ technologies such as WebSockets or real-time messaging protocols to provide an interactive and responsive chat experience for users. It efficiently manages the delivery, storage, and routing of messages among the team members, making it an essential component for promoting effective and immediate team interaction within the Teamify application.

### PERSISTANCE EVALUATION
The messaging container does not need to store message data persistently as its primary function is to enable real-time communication. However, to ensure a smooth and efficient chat experience, it should keep temporary message queues and possibly recent chat history in memory for a short period. This would aid in message delivery and synchronization, especially when users experience brief network interruptions. Additionally, this container may need to store transient data such as user session details and presence information to manage the state of ongoing chat sessions.

### EXTERNAL SERVICES CONNECTIONS
The messaging container may require connections to external services, such as real-time messaging services or protocols like WebSockets, to facilitate the instant delivery and receipt of messages. Additionally, it may need to connect to advanced message routing services to ensure messages are delivered correctly even in distributed system topologies. If multimedia messaging is supported, it could also connect to file storage services to handle the temporary storage of sent media files.

### MICROSERVICES:

#### MICROSERVICE: chat_service
- TYPE: backend
- DESCRIPTION: This microservice handles real-time chat functionalities within teams. It facilitates sending and receiving messages in a group chat through a web-socket connection. The microservice ensures instant message delivery and manages user connections, session details, and transient presence information to maintain the state of ongoing chat sessions.
- PORTS: 10600
- TECHNOLOGICAL SPECIFICATION
The chat_service microservice will utilize Node.js for its flexibility and support of non-blocking operations, crucial for real-time applications. The framework choice is Socket.IO, which facilitates WebSocket connections and provides simple and robust real-time messaging capabilities, including automatic fallbacks to HTTP polling in environments without WebSocket support. To manage user sessions and presence information, a library such as Redis is recommended due to its in-memory data structure store and capabilities for session management.
- SERVICE ARCHITECTURE
The architecture of the chat_service adheres to a modular design pattern. The service will separate concerns into distinct modules:
- **Connection Management Module**: This module handles incoming WebSocket connections, ensuring that each user session is properly managed and maintained.
- **Message Handling Module**: Responsible for capturing incoming messages, processing them, and directing them to the correct channels or groups via Socket.IO. This module ensures efficient message handling and delivery.
- **Session Management**: Utilizes Redis for storing transient data, such as session details and user presence state, facilitating quick reconnection and session maintenance.
- **Integration Layer**: Interfaces with the message_router microservice, forwarding messages and receiving them as needed for routing purposes.
The architecture supports a pub/sub pattern, leveraging features of Redis to manage room subscriptions and event broadcasting to ensure that messages are delivered in real-time to all subscribed users within a group chat.
- ENDPOINTS
HTTP Method	Endpoint URL	Description	User Stories
CONNECT	/chat_service/connect	Establish a WebSocket connection for a team member to enable real-time chat capabilities and maintain user session	21
POST	/chat_service/send	Send a message in a group chat for real-time communication among team members	21
GET	/chat_service/receive	Receive messages in real-time as part of the group chat using a WebSocket connection	21
DISCONNECT	/chat_service/disconnect	Terminate the WebSocket connection to end the chat session for the user and manage user presence	21

#### MICROSERVICE: message_router
- TYPE: middleware
- DESCRIPTION: This microservice manages the routing of messages among team members. It ensures messages are correctly directed to intended recipients in a distributed system topology, supporting the chat service. It may use external advanced message routing services to ensure availability and reliability.
- PORTS: 10610


## CONTAINER NAME: polls

### USER STORIES:
22) As a team administrator, I want to create a poll, so that I can know the opinions of the other members related to a specific topic.
23) As a team member, I want to see the results of a previously created poll, so that I can know the opinions of the other members related to a specific topic.
24) As a team member, I want to vote for a poll, so that I can express my opinion with respect to a specific topic.
### PORTS: 10700:10799

### DESCRIPTION: 
The polls container in Teamify is specifically designed to manage and facilitate polling functionalities within teams. This container allows team administrators to create polls aimed at gathering opinions or making decisions on specific topics pertinent to the team. It supports the complete lifecycle of a poll, including creation by the team administrator, participation by team members, and the visualization of poll results. Team members can cast their votes to express their opinions, and subsequently review the results once the poll is closed or voting is complete. This encourages collaborative decision-making and helps ensure that all team members' voices are heard. The container operates on ports 10700 through 10799, providing an isolated and secure environment for handling polling operations separate from other functionalities in the Teamify ecosystem.

### PERSISTANCE EVALUATION
The polls container needs to store data to fulfill its purpose and user stories. It is essential to store details of each poll, including the poll questions, options, creator, and associated team. The system should also persist each user’s vote to ensure accurate results and prevent multiple votes from the same user. Finally, storing the overall poll results is needed for result visualization once the polling period has concluded.

### EXTERNAL SERVICES CONNECTIONS
Based on the container's purpose and user stories, there is no inherent need for the polls container to connect to any external services. The functionalities surrounding poll creation, voting, and result visualization are internal to the Teamify application and are primarily focused on handling data generated by users within the platform.

### MICROSERVICES:

#### MICROSERVICE: poll_creation
- TYPE: backend
- DESCRIPTION: This microservice handles the creation of polls by team administrators. It facilitates the input of poll questions, options, and associates the poll with the designated team. It ensures that polls are appropriately configured and stored for subsequent interactions.
- PORTS: 10701
- TECHNOLOGICAL SPECIFICATION
The 'poll_creation' microservice will use Python as the primary programming language with the Django framework for building robust RESTful APIs. Django's built-in ORM will facilitate interaction with persistent storage like PostgreSQL for handling poll-related data efficiently. Libraries such as Django REST Framework will be used to streamline API development, and Celery could be considered for handling asynchronous tasks like sending notifications or closing polls at specific times.
- SERVICE ARCHITECTURE
The 'poll_creation' service adopts the layered architecture pattern. It consists of a presentation layer managing HTTP requests and responses, an application layer containing business logic for poll creation, and a data access layer responsible for interactions with the database. A separate service layer ensures clean separation of concerns, making it easy to handle inputs and perform related operations before interacting with the data access layer. Communication between layers relies on Django's views, serializers for data validation, and models to interface with the database. The service also implements a repository pattern within the data access layer to abstract and encapsulate all interactions with storage systems for greater flexibility and maintainability.
- ENDPOINTS
HTTP Method	Endpoint URL	Description	User Stories
POST	/polls/create	Create a new poll for a team based on the provided questions and options by the team administrator.	22
GET	/polls/results/{poll_id}	Retrieve and display the results of a specified poll, allowing team members to understand opinions expressed in the poll.	23
POST	/polls/vote	Cast a vote on a specified poll, ensuring that each team member contributes their opinion on the topic.	24

#### MICROSERVICE: voting
- TYPE: backend
- DESCRIPTION: This microservice manages the voting process for team members. It allows users to cast their votes on active polls, ensures that a user can vote only once per poll, and records each vote in the database for accurate result computation.
- PORTS: 10702
- TECHNOLOGICAL SPECIFICATION
The microservices in the polls container will use Node.js as their main programming language due to its efficiency in handling asynchronous operations and real-time updates, which are fundamental for managing polling activities. The Express.js framework will be utilized for backend services to create RESTful APIs. For the database microservice (poll_storage), MongoDB will be employed given its flexibility in handling varying structures of poll-related data. Additionally, Mongoose will be used as an Object Data Modeling (ODM) library to easily manage data relationships in the MongoDB database.
- SERVICE ARCHITECTURE
The service architecture for the polls container follows a microservices pattern, where each functionality of the polling process is isolated into distinct microservices, facilitating scalability and maintainability. The poll_creation service implements the Command Query Responsibility Segregation (CQRS) pattern, separating the command operations for poll creation from the query side responsible for retrieving poll information. The voting and result_visualization services adopt a layered architecture with clear separation of concerns, consisting of a presentation layer for handling input/output, business logic layer for processing votes and results, and data access layer for communication with the poll_storage microservice. The use of RESTful APIs for communication between microservices ensures a loose coupling and promotes the independent evolution of each service.
- ENDPOINTS
HTTP Method	Endpoint URL	Description	User Stories
POST	/polls/create	Create a new poll using the inserted information by a team administrator, ensuring it is stored and accessible for voting	22
POST	/polls/vote	Allow a team member to cast a vote on a specified poll, ensuring each user votes only once	24
GET	/polls/results	Retrieve and display the results of a specified poll to team members once voting is complete	23

#### MICROSERVICE: result_visualization
- TYPE: backend
- DESCRIPTION: This microservice is responsible for compiling and displaying poll results to users. It retrieves the recorded votes, calculates the results, and presents the outcomes to team members, facilitating transparency and informed decision-making.
- PORTS: 10703
- TECHNOLOGICAL SPECIFICATION
The result_visualization microservice within the polls container will be developed using Python as the primary programming language, leveraging the Flask framework for building RESTful APIs. Flask is lightweight and well-suited for backend services that require handling HTTP requests and responses. The microservice will employ SQLAlchemy as the ORM (Object-Relational Mapping) to interact with the poll_storage database, allowing for seamless retrieval of recorded votes and results computation. For data presentation and visualization, libraries such as Matplotlib and Jinja2 will be utilized to render dynamic HTML templates that display calculated poll outcomes in a user-friendly format. These technologies provide both flexibility and scalability to accommodate future enhancements.
- SERVICE ARCHITECTURE
The result_visualization microservice adopts a service-oriented architecture with a layered design. It employs the Model-View-Controller (MVC) pattern to effectively separate concerns, allowing the microservice to handle data retrieval, business logic processing, and result presentation independently. The model layer, managed by SQLAlchemy, interfaces with the poll_storage database to fetch the necessary data for computations. The controller layer, implemented using Flask, manages the logic to calculate poll results and prepares them for presentation. The view layer utilizes Jinja2 templates to dynamically render HTML pages that visually depict poll outcomes to team members. Additionally, the microservice includes a RESTful API layer that provides endpoints for querying poll results, enabling other parts of the Teamify application to access and display these results as required. This architectural pattern ensures maintainability, scalability, and the ability to integrate with other system components, fostering efficient data flow and user interaction.
- ENDPOINTS
HTTP Method	Endpoint URL	Description	User Stories
GET	/polls/{poll_id}/results	Retrieve and display the poll results for a specific poll to team members, enabling informed decision-making within the team.	23
GET	/polls/results/summary	Provide a summary of results for all completed polls, offering a comprehensive view of the team’s collective opinions.	23

#### MICROSERVICE: poll_storage
- TYPE: database
- DESCRIPTION: This microservice is dedicated to storing poll-related data, including poll questions, options, votes cast by users, and final poll results. It ensures data persistence and integrity throughout the lifecycle of a poll.
- PORTS: 10720


## CONTAINER NAME: frontend

### PORTS: 10800:10899
### DESCRIPTION: 
The frontend container is responsible for managing and displaying the user interface of the Teamify software solution. It serves as the interface through which users interact with all components of the system, including personal task management, team collaboration, real-time chat, notifications, and more. This container ensures that the user experience is intuitive and seamless, providing access to various functionalities such as creating and managing tasks, viewing and editing user profiles, receiving notifications, engaging in team chats, and participating in polls. The frontend container makes these interactions possible by connecting and orchestrating requests between the user's browser and the appropriate backend microservices, while also rendering the visual elements necessary for effective user engagement.

### PERSISTANCE EVALUATION
The frontend container does not inherently require data storage to fulfill its purpose and user stories. It primarily functions as the interface between users and backend services, facilitating interaction through rendering visual content and managing the communication with backend services for user interactions. Any state or temporary data would typically be maintained in memory on the client's device, not stored persistently within the frontend container.

### EXTERNAL SERVICES CONNECTIONS
Based on the frontend container's purpose and user stories, it does not directly require connections to external service providers. However, it relies heavily on internal connections to various backend microservices to fetch and send user data, handle authentication, manage tasks, and other operations. External services might be indirectly utilized by backend services, but the frontend's role is limited to interfacing with in-house services.

### MICROSERVICES:

MICROSERVICE: ui
- TYPE: frontend
- DESCRIPTION: This microservice is responsible for rendering the user interface, managing and displaying the visual components, and facilitating user interactions with the system. It provides a seamless interaction layer for users to engage with functionalities such as task management, team collaboration, and real-time chat by communicating with backend services.
- PORTS: 10800
- TECHNOLOGICAL SPECIFICATION
The ui microservice leverages modern web development technologies. It uses JavaScript with the React framework to provide a dynamic and responsive user interface. React is chosen for its component-based architecture, allowing for reusable UI components and efficient rendering. For styling, CSS-in-JS solutions such as styled-components or Emotion can be used, providing scoped styling capabilities and compatibility with React components. Communication with backend microservices is handled through Axios or Fetch API for asynchronous HTTP requests, facilitating interaction with the api-gateway. Additionally, state management within the UI can be achieved using React Context API or a state management library like Redux or MobX to manage the application state effectively across components.
- SERVICE ARCHITECTURE
The architecture of the ui microservice adopts a single-page application (SPA) pattern facilitated by React, enhancing user experience with quick navigation and reduced page-load times. It includes several design patterns and architectural components:
1. **Component-Based Architecture**: The application is broken down into modular, self-contained components. Each component is responsible for rendering a part of the UI, managing its own state, and potentially communicating with other components.
2. **Client-Side Routing**: Utilizing libraries such as React Router, the ui microservice supports seamless navigation between different views without full page reloads, providing a fluid user experience typical of SPAs.
3. **State Management**: Application-wide state management is handled using either React Context API or Redux, providing a predictable and centralized management of the application state, which is particularly beneficial when managing complex application data flows.
4. **API Communication Layer**: The microservice employs an HTTP client library like Axios to abstract and handle API requests and responses. This layer ensures clean separation between UI components and data fetching logic, adhering to the separation of concerns principle.
Overall, the ui microservice is designed to deliver a robust and responsive front-end user experience while maintaining a clean separation of responsibilities through component-based design and effective state and API management practices.
- PAGES
Page Name	Description	User Stories
Dashboard	Provides an overview of personal tasks, notifications, and team activities	N/A
Task Management	Interface for creating, editing, and managing personal and team tasks	N/A
User Profile	Allows viewing and editing of user profiles	N/A
Team Collaboration	Facilitates team chat and collaborative interactions	N/A
Real-Time Chat	Enables real-time communication with team members	N/A
Notifications	Displays user notifications and alerts	N/A
Polls	Allows participation in team polls and view poll results	N/A

#### MICROSERVICE: api-gateway
- TYPE: middleware
- DESCRIPTION: Acts as a middleware microservice facilitating communication between the frontend and backend services. It routes user requests from the frontend to appropriate backend microservices handling tasks such as authentication, task management, and notifications, ensuring secure and efficient data exchange.
- PORTS: 10801