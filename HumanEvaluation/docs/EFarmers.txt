EFarmers Project proposed by ArchiGPT-4o :

# CONTAINERS

## CONTAINER NAME: user_management
### USER STORIES:
1) As a visitor, I want to register to the website with an email
2) As a user, I want to logout from my account
3) As a user, I want to reach a login page so that I can login into my account
6) As a user, I want to access my personal page, so that I can see my informations
12) As a customer, I want to update my status to Farmer
24) As a customer, I want to update my status to Rider, so that I can deliver stuffs.
30) As a user, I want to be able to modify my informations
29) As a visitor, I want to register to the website with OAuth
### PORTS: 10000:10100
### DESCRIPTION: 
The user_management container is responsible for the crucial aspect of handling user accounts and authentication within the E-Farmers platform. This container facilitates the registration process for new users, allowing them to create accounts either with an email or by using OAuth for authentication. Once registered, users can log in and log out of their accounts seamlessly.
It also manages user profiles, providing users with the ability to access their personal pages where they can view and update their personal information. Additionally, it supports role transitions, enabling customers to update their status to Farmer or Rider, thus expanding their functionalities within the platform. The container takes care of ensuring secure management of user credentials and acts as an access point for personalized services by storing and updating user profiles as needed.
By handling these critical functions, the user_management container serves as the backbone of user-related operations, ensuring that users have a smooth experience when managing their account details, whether they are visitors just signing up or existing users updating their profiles and account status.
### PERSISTANCE EVALUATION
The user_management container needs to store data to handle user accounts and authentication effectively. This involves storing user credentials such as email addresses and password hashes for secure login and registration processes. Additionally, it must store OAuth tokens for users registering or logging in via third-party services. The container will also persist user profile information, which includes personal details that users can view and modify. Furthermore, it must track the users' roles (e.g., Customer, Farmer, Rider) and allow for status updates as needed. This ensures users have access to their personal pages and can update their information and roles effectively.
### EXTERNAL SERVICES CONNECTIONS
The container will need to connect to external services for OAuth registration and authentication, as indicated by the user story that allows visitors to register using OAuth. This will involve integrating with identity providers like Google, Facebook, or others that provide OAuth services. Besides OAuth, the container does not require further connections to external services, as its primary functionality revolves around internal user management within the E-Farmers platform.
### MICROSERVICES:
#### MICROSERVICE: user_authentication
- TYPE: backend
- DESCRIPTION: This microservice handles user authentication processes, including login, logout, and registration using email. It also supports authentication using OAuth providers such as Google and Facebook. It interacts with the database to validate user credentials and store OAuth tokens.
- PORTS: 10010
- TECHNOLOGICAL SPECIFICATION
The `user_authentication` microservice employs Node.js for its versatility and efficiency in handling asynchronous operations, which is ideal for handling user authentication and interacting with external OAuth providers without blocking the main thread. The Express framework is used to facilitate the development of RESTful APIs crucial for the microservice's operations. Additional libraries such as `Passport.js` are integrated to manage complex authentication scenarios, especially for OAuth processes, allowing seamless integration with third-party identity providers like Google and Facebook. For secure storage of user credentials, `bcrypt` is utilized for hashing passwords, ensuring data integrity and security. JWT (JSON Web Tokens) may also be used for session management to ensure secure and scalable handling of user sessions.
- SERVICE ARCHITECTURE
The service architecture follows a modular pattern, separating concerns and responsibilities across different components for better maintainability and scalability. This involves:
1. **Routing Layer**: Handles all incoming requests and routes them to the appropriate controller functions based on the requested endpoints. It serves as the microservice's entry and exit point, ensuring logical separation from business logic.
2. **Controller Layer**: Manages incoming requests by executing business logic and delegating tasks to services. It interacts with the authentication logic, managing user sessions, logging users in and out, registering new users, and integrating OAuth flows.
3. **Service Layer**: Encapsulates business logic related to user authentication operations, such as verifying credentials and communicating with third-party OAuth providers. This layer ensures that controllers can focus on request handling without deep involvement in business processes.
4. **Data Access Layer (Repository Pattern)**: Provides an abstract interface to the `user_data_store` microservice, facilitating safe, secure, and efficient data interaction. This includes persisting user credentials, retrieving user data, ensuring abstraction from the underlying data storage details.
5. **Middleware**: Includes security and authentication checks, parsing requests, and handling errors consistently. Middleware components are used to enforce authentication layers, manage sessions with JWT, and handle errors systematically.
Overall, the service's architecture embraces the single responsibility principle and separation of concerns to ensure a clean, scalable, and maintainable solution.
- ENDPOINTS
HTTP Method	Endpoint URL	Description	User Stories
POST	/user_authentication/register/email	Register a new user using an email address and store credentials securely.	1
POST	/user_authentication/register/oauth	Register a new user using OAuth from providers such as Google or Facebook.	29
POST	/user_authentication/login	Authenticate a user by verifying their credentials and start a session.	3
POST	/user_authentication/logout	Log out a user by ending their current session and invalidating their token.	2
GET	/user_authentication/profile	Retrieve the personal page of an authenticated user to view their details.	6
PUT	/user_authentication/profile/update	Allow users to modify their personal information.	30

#### MICROSERVICE: profile_management
- TYPE: backend
- DESCRIPTION: This microservice allows users to access and update their personal information. It manages user profiles, including basic details and allows the modification of roles, such as transitioning a customer to a Farmer or Rider.
- PORTS: 10020
- TECHNOLOGICAL SPECIFICATION
The appropriate technological stack for the user_management container involves leveraging Node.js for its backend development, utilizing Express as the web framework for creating RESTful APIs. The authentication processes will be managed using the Passport library, which is well-suited for handling both local authentication and a wide range of OAuth providers. For persistent data storage, PostgreSQL will be employed, along with Sequelize ORM to facilitate easier data interactions. Integration with external OAuth providers such as Google and Facebook requires supporting libraries like passport-google-oauth and passport-facebook for seamless authentication handling. The system will use Docker to encapsulate the container, ensuring the environment's consistency and dependencies.
- SERVICE ARCHITECTURE
The service architecture adopts a microservices-based design pattern with a clear delineation of responsibilities for each microservice. The user_authentication microservice implements a model-controller-service pattern, where models represent data structures, controllers handle incoming requests and call the service layer for business logic related to authentication. The profile_management microservice follows the same pattern, focusing on user profile data management and update operations. The role_management microservice is designed using the command pattern to efficiently handle role transitions, encapsulating requests to change user roles as command objects with invoker services executing them. The user_data_store acts as a data repository and implements the repository pattern, centralizing database transactions and providing an abstraction layer to keep business logic separate from data access code. This pattern ensures ease of maintenance and scalability within the microservices architecture, supporting seamless interaction among service components.
- ENDPOINTS
HTTP Method	Endpoint URL	Description	User Stories
POST	/user_authentication/register	Register a new user with an email, ensuring their details are stored in the database	1
POST	/user_authentication/register/oauth	Register a new user using OAuth with external providers such as Google or Facebook	29
POST	/user_authentication/login	Handle user login using provided credentials or OAuth tokens to allow access to the platform	3
POST	/user_authentication/logout	Log out the currently authenticated user by invalidating their session or token	2
GET	/profile_management/profile	Retrieve the authenticated user's profile information to display on their personal page	6
PUT	/profile_management/profile	Update the authenticated user's personal information within their profile	30
POST	/role_management/update/farmer	Update the user's status to Farmer, granting them corresponding functionalities	12
POST	/role_management/update/rider	Update the user's status to Rider, allowing them to access delivery functionalities	24

#### MICROSERVICE: role_management
- TYPE: backend
- DESCRIPTION: This microservice specifically handles role transitions, allowing users to update their status to Farmer or Rider. It ensures that role changes are reflected in user profiles and grants corresponding permissions and functionalities.
- PORTS: 10030
- TECHNOLOGICAL SPECIFICATION
For the role_management microservice, a robust backend stack is essential to efficiently handle role transitions and update related user permissions. The choice of NodeJS as the main programming language, paired with the Express framework, offers the scalability and flexibility required for this service. The NodeJS ecosystem supports asynchronous operations and integrates seamlessly with JSON data formats, which is crucial for communicating with other microservices such as profile_management and user_data_store. Key libraries to consider include Mongoose for efficient MongoDB interaction, Passport.js for role-based access control, and JWT for secure token handling. Additionally, any interaction with external OAuth services should be facilitated using Passport-Strategies for third-party logins, ensuring consistent management of user roles and permissions.
- SERVICE ARCHITECTURE
The role_management microservice adopts a microservices architecture pattern focused on role-based access control and user management functionalities. It is structured to implement a modular architecture pattern, with each module responsible for specific aspects such as role validation, role updates, and permissions assignment. A RESTful API design is adopted to expose endpoints for role transition operations, allowing seamless integration with the user_authentication and profile_management microservices. Communication with the user_data_store is achieved through a repository pattern, allowing for clean separation of business logic from data access code. The service also uses middleware components extensively to handle certification of user access levels and proper routing of requests based on current user roles and requested transitions.
- ENDPOINTS
HTTP Method	Endpoint URL	Description	User Stories
POST	/role/upgrade/farmer	Enable a user to upgrade their status to Farmer, updating their permissions and reflecting changes in their profile.	12
POST	/role/upgrade/rider	Allow a customer to upgrade their status to Rider, granting delivery permissions and updating their profile attributes.	24

#### MICROSERVICE: user_data_store
- TYPE: database
- DESCRIPTION: This microservice is responsible for storing user-related data, including credentials, OAuth tokens, and user profiles. It also tracks user roles and supports reliable data retrieval and updates for user management functionalities.
- PORTS: 10040

## CONTAINER NAME: insertion_management

### USER STORIES:
4) As a farmer, I want to publish a new insertion
9) As a the owner of an insertion, I want to delete one of my insertions
10) As a farmer, I want to modify my insertions
31) As a the owner of an insertion, I want to be able to add boxes on my insertion
### PORTS: 10200:10300
### DESCRIPTION: 
The "insertion_management" container is a critical component of the E-Farmers e-commerce platform, primarily responsible for empowering farmers to manage their product listings effectively. Its main behavior includes:
1. **Creation of Insertions:** It provides farmers with the ability to publish new product insertions, facilitating the showcasing of their products to potential customers.
2. **Modification and Deletion:** Farmers can modify existing insertions to update product details or remove them when they are no longer available. This ensures that all published information is current and accurate.
3. **Addition of Boxes:** The container allows farmers, as the insertion owners, to add boxes to their product listings, potentially for packaging or bundling purposes, providing more flexibility in presenting their offerings.
By handling these functionalities, the "insertion_management" container plays a significant role in the lifecycle management of product insertions, enabling farmers to maintain control over their online presence and product availability, ultimately enhancing their ability to connect with customers through the platform. This service operates on ports 10200 to 10300.
### PERSISTANCE EVALUATION
The "insertion_management" container requires data persistence to efficiently manage the creation, modification, deletion, and management of product insertions by farmers. Specifically, it needs to store:
1. Details of each insertion, such as product name, description, price, and availability status.
2. Historical records of changes made to product insertions for tracking and audit purposes.
3. Metadata regarding product boxes, which may include types, quantities, and packaging details.
### EXTERNAL SERVICES CONNECTIONS
Based on the container's purpose and user stories, there is no immediate requirement for the "insertion_management" container to connect with external service providers. Its primary functions related to product management can be handled internally within the e-commerce platform. However, if additional functionalities like fetching real-time pricing data or handling images are envisioned in the future, connections to external APIs or cloud storage services might be necessary.
### MICROSERVICES:
#### MICROSERVICE: insertion_handler
- TYPE: backend
- DESCRIPTION: This microservice manages the creation, modification, and deletion of product insertions by farmers. It provides the core logic for publishing new product listings, updating existing information, and removing outdated or unavailable products. It ensures that only valid and accurate information is displayed on the platform.
- PORTS: 10210
- TECHNOLOGICAL SPECIFICATION
The "insertion_handler" microservice will use Python as its primary programming language due to its versatility and robust ecosystem. The Flask framework is chosen for building the backend RESTful API which will efficiently handle HTTP requests and manage product insertions. Flask-RESTful will be used to enhance the API design. For data validation and serialization, Marshmallow will be used. The microservice will interface with the "insertion_database" microservice using SQLAlchemy, an ORM that will handle interactions with the database, ensuring that the insertion data is correctly stored and maintained.
- SERVICE ARCHITECTURE
The "insertion_handler" service will adopt a layered architecture pattern to maintain clean separation between different aspects of the application. It will consist of the following layers:
1. **Presentation Layer**: Handles incoming HTTP requests via Flask, with distinct routes pointing to specific functionalities such as creating, updating, or deleting product insertions.
2. **Business Logic Layer**: Contains the core logic associated with the insertion management. This includes validation, authorization checks, and the application of business rules before inserting or modifying data in the database.
3. **Persistence Layer**: Uses SQLAlchemy to interact with the "insertion_database" microservice. It will encapsulate database access and manage transactions efficiently, ensuring data integrity and consistency.
To facilitate communication between the insertion components (i.e., "insertion_handler" and "box_manager"), a service interface using RESTful endpoints will be established, allowing reliable interaction and coordination of tasks related to insertions. This architecture ensures that the microservice is modular, scalable, and maintainable.
- ENDPOINTS
HTTP Method	Endpoint URL	Description	User Stories
POST	/insertion_handler/insertion	Create a new product insertion, allowing farmers to publish their products on the platform.	4
PUT	/insertion_handler/insertion/<insertion_id>	Modify an existing insertion to update product details, ensuring accurate and up-to-date information is displayed.	10
DELETE	/insertion_handler/insertion/<insertion_id>	Delete an existing insertion, removing it from the platform when the product is no longer available.	9

#### MICROSERVICE: box_manager
- TYPE: backend
- DESCRIPTION: This microservice handles the addition and management of boxes to product insertions. It allows farmers to define packaging or bundling details of their products, offering additional flexibility in how products are showcased and sold to customers.
- PORTS: 10220
- TECHNOLOGICAL SPECIFICATION
The "insertion_management" container utilizes Python as its primary programming language. The Django framework is employed to facilitate rapid development and to provide a robust backend system, particularly well-suited for handling relational data and operations on it, such as CRUD (Create, Read, Update, Delete) actions. For database operations, the PostgreSQL database is leveraged due to its advanced feature set, including JSON support for flexibility in storing metadata related to boxes. API endpoints are provided through Django REST Framework to ensure a consistent and standardized interface for interacting with the insertion management functionalities. Key libraries include Django ORM for database interactions, and Django REST Framework for API development.
- SERVICE ARCHITECTURE
The service architecture adopts a layered architecture pattern, where the business logic is distinctly separated from the database layer and presentation/API layer. The architecture consists of the following layers:
- **Presentation/API Layer:** This layer is responsible for handling HTTP requests using Django REST Framework. It provides end-points for operations like creating, modifying, and deleting insertions, as well as managing boxes for insertions.
- **Business Logic Layer:** The core logic for insertion management is encapsulated in this layer, using Django's model-view-controller architecture. The business rules for validation and data manipulation are implemented here to ensure data integrity and adherence to business requirements.
- **Persistence/Data Access Layer:** Utilizing Django's ORM, this layer interacts directly with the PostgreSQL database to perform data operations. It manages the persistence of insertion data, historical records, and metadata related to product boxes.
Overall, the adoption of these architectural patterns ensures that the "insertion_management" service is scalable, maintainable, and can easily be extended to incorporate potential future dependencies or additional functionalities, such as external API integrations for image handling or real-time data fetching.
- ENDPOINTS
HTTP Method	Endpoint URL	Description	User Stories
POST	/insertions	Create a new product insertion with details provided by the farmer, returns confirmation of insertion creation	4
PUT	/insertions/{id}	Modify an existing product insertion identified by its ID with updated details, returns confirmation of update	10
DELETE	/insertions/{id}	Delete an existing product insertion identified by its ID, returns confirmation of deletion	9
POST	/insertions/{id}/boxes	Add packaging or bundle details to a product insertion by its ID, returns confirmation of box addition	31

#### MICROSERVICE: insertion_database
- TYPE: database
- DESCRIPTION: This microservice serves as the database for storing all insertion-related data including product details, historical change records, and metadata regarding product boxes. It ensures persistence and easy retrieval of all insertion-related information.
- PORTS: 10230

## CONTAINER NAME: navigation

### USER STORIES:
5) As a user, I want to access the home page
13) As a user, I want to access a farmer page, so I can see his information
### PORTS: 10400:10500
### DESCRIPTION: 
The navigation container is responsible for managing the central navigation features of the E-Farmers platform. Its primary purpose is to ensure users have seamless access to the main interface components, specifically the home page and individual farmer pages. This container supports the user stories that require navigating to the home page where a broad overview of the platform and its offerings can be seen, as well as accessing specific farmer pages where detailed information about farmers and their products is provided. By ensuring smooth navigation between these key pages, the navigation container enhances user experience and helps users easily locate and explore desired content within the platform. Using specific port configurations (10400:10500), it facilitates interaction between the user interface and the rest of the system's functionalities, ensuring fluid and intuitive movement across different sections of the e-commerce website.
### PERSISTANCE EVALUATION
The navigation container does not require persistent storage as its primary function is to manage and facilitate navigation between different pages on the platform. It does not directly handle any data that needs to be stored long-term; instead, it focuses on rendering and routing users to different sections such as the home page and farmer pages.
### EXTERNAL SERVICES CONNECTIONS
Based on the container's behavior and user stories, the navigation container does not need to connect to any external services. Its primary function is internal to the system, facilitating transitions and access to different parts of the platform. Therefore, it operates independently of external service providers.
### MICROSERVICES:
#### MICROSERVICE: home_page
- TYPE: frontend
- DESCRIPTION: The microservice is responsible for rendering the home page of the platform, presenting users with an overview of available products, announcements, and featured farmers. It handles routing to other sections from the homepage.
- PORTS: 10410
- TECHNOLOGICAL SPECIFICATION
The home_page microservice will utilize React.js as its main frontend framework due to its efficiency in building dynamic and responsive user interfaces. For state management, Redux can be employed to handle complex state interactions, ensuring that the homepage updates seamlessly with changes across the platform. Depending on the complexity of UI components, additional libraries such as React Router will be used to manage routing, and Axios can be leveraged for any potential data fetching needs or interaction with backend services.
- SERVICE ARCHITECTURE
The home_page microservice will adopt a component-based architecture, which is a hallmark of React.js applications. This pattern allows for each part of the homepage (such as the header, product lists, or announcements section) to be a reusable component, encapsulating its own logic and styling. This architectural approach facilitates maintainability and scalability, allowing developers to easily manage and update individual pieces of the UI. Furthermore, React Router will be utilized to handle the transitions between different application views, leveraging route matching capabilities to navigate and render components appropriately based on user interaction.
- PAGES
Page Name	Description	User Stories
HomePage	Renders the home page of the platform with an overview of products, announcements, and featured farmers. It provides navigation to other sections from the homepage.	5
FarmerPage	Displays detailed information about each farmer and their products, facilitating navigation from the home page to specific farmer pages.	13

#### MICROSERVICE: farmer_page
- TYPE: frontend
- DESCRIPTION: The microservice manages the rendering of individual farmer pages, displaying detailed information about each farmer and their products. It facilitates navigation from the home page to specific farmer pages.
- PORTS: 10420
- TECHNOLOGICAL SPECIFICATION
The "farmer_page" microservice, as a frontend microservice, would benefit from using a modern web development stack that ensures performance and flexibility. React.js, a popular JavaScript library for building user interfaces, is an excellent choice for delivering dynamic and responsive user experiences. Additionally, for state management, Redux can be employed to efficiently manage the application state, especially when dealing with the navigation and dynamic updates of farmer information. To simplify HTTP requests and API calls, axios would be useful, and for routing within the React ecosystem, React Router would facilitate seamless navigation between the home page and individual farmer pages.
- SERVICE ARCHITECTURE
The "farmer_page" microservice adopts a component-based architecture pattern typical of frontend applications built with React.js. Each part of the user interface is divided into reusable components, such as FarmerCard, ProductList, and FarmerDetails. State management is centralized using Redux, which decouples the application state from the UI components, promoting scalability and maintainability. React Router is utilized to implement a client-side routing system, enabling smooth transitions between pages without requiring full-page reloads. This pattern enhances the user experience by allowing fast and intuitive navigation across the platform. Additionally, the routing microservice acts as a middleman, using a middleware pattern to direct traffic between the user interface components effectively.
- PAGES
Page Name	Description	User Stories
HomePage	Renders the platform's home page, showcasing available products, announcements, and featured farmers.	5
FarmerPage/<id>	Displays detailed information about individual farmers and their products.	13

#### MICROSERVICE: routing
- TYPE: middleware
- DESCRIPTION: This microservice handles routing logic to ensure smooth navigation and transition between home page and farmer pages as well as other related navigation tasks within the platform.
- PORTS: 10430


## CONTAINER NAME: search_functionality

### USER STORIES:
8) As a user or visitor, I can search for farmer's insertions
### PORTS: 10600:10700
### DESCRIPTION: 
The search_functionality container is responsible for providing users and visitors with the ability to search for farmer insertions on the E-Farmers platform. It facilitates comprehensive search capabilities, allowing users to efficiently find the specific products and offerings that farmers have listed. This container manages the search requests, processes them to determine relevant insertion results, and delivers these results back to the users to enhance their browsing and shopping experience. Through this functionality, users can quickly discover fresh and locally sourced products that meet their preferences, thereby enhancing the usability and convenience of the e-commerce platform.
### PERSISTANCE EVALUATION
The search_functionality container does not inherently need to store any persistent data directly as its primary purpose is to handle search queries and return relevant results. However, it may require leverage of a search index or caching mechanism to improve search performance and efficiency. The search index could be populated and updated by information from the insertion_management container, which handles product listings data. Such mechanisms would typically not involve direct storage within the search_functionality container but would interact with a centralized index or cache optimized for search operations.
### EXTERNAL SERVICES CONNECTIONS
Based on the container's purpose and user stories, there may be a need to utilize external services for enhanced search functionality, such as an external search engine API (e.g., Elasticsearch or Algolia) to manage and perform searches efficiently. These services offer powerful search capabilities, including full-text search, filtering, and ranking, which can significantly improve the quality and speed of search results returned to users. However, these would not be classified strictly as "external providers" since these search services can be containerized and part of the overall system architecture.
### MICROSERVICES:
#### MICROSERVICE: search_backend
- TYPE: backend
- DESCRIPTION: This microservice processes search queries from users and visitors, interacts with the search index or caching mechanism to find relevant farmer insertions, and returns search results. It may connect with external search services like Elasticsearch or Algolia to enhance the search functionality with features such as full-text search and filtering.
- PORTS: 10610
- TECHNOLOGICAL SPECIFICATION
The search_backend microservice uses Python as its primary programming language, utilizing the FastAPI framework for developing robust, high-performance RESTful APIs. Libraries such as Pydantic and SQLAlchemy may assist in data validation and ORM, although direct persistence is not required. Interaction with search indexing services like Elasticsearch or Algolia will be managed through their respective client libraries. To improve search speed and relevancy, additional libraries like Whoosh or simplejson could be used for lightweight local indexing and JSON manipulation.
- SERVICE ARCHITECTURE
The service architecture employs a microservice pattern where the search_backend plays a central role in orchestrating search operations. It operates as a stateless service that interacts with an external search engine (e.g., Elasticsearch) maintaining a separation of concerns. The search_backend microservice follows a model-view-controller (MVC) pattern where the model part interfaces with the search_index, the controller manages incoming search requests, and the view sends processed results to users. Furthermore, the architecture adopts a CQRS (Command Query Responsibility Segregation) pattern for separation between query (search) and update operations, optimizing performance especially when dealing with real-time and complex queries.
- ENDPOINTS
HTTP Method	Endpoint URL	Description	User Stories
GET	/search	Process search queries submitted by users and visitors, querying a search index or external service to find and return relevant farmer insertions.	8

#### MICROSERVICE: search_index
- TYPE: database
- DESCRIPTION: This microservice maintains a search index that is updated with information from the insertion_management container. It optimizes search operations by providing quick access to relevant search data.
- PORTS: 10620


## CONTAINER NAME: cart_and_order_management

### USER STORIES:
14) As a customer, I want to add a product in my cart, so that I buy this product
15) As a customer, I want to delete the boxes added to the shopping cart
16) As a customer. I want to generate an order which contains items from my shopping cart
17) As a customer, I want to be able to checkout and pay for my order using a secure payment gateway.
22) As a customer, I want to check my order history, so I can remember past purchases
33) As a user, I want to see my cart, so I can see all the products I am about to purchase
### PORTS: 10800:10900
### DESCRIPTION: 
The "cart_and_order_management" container is a crucial component of the E-Farmers e-commerce platform. Its primary purpose is to manage the shopping cart and order-related functionalities for customers. This container facilitates several key actions for the customer:
1. **Add and Manage Cart Items:** It allows customers to add products to their shopping cart, providing a virtual space for them to collect items they intend to purchase. Customers can also delete boxes or products from their cart, offering flexibility while they shop.
2. **Order Generation and Checkout Process:** Once a customer finalizes their selection, this container enables them to generate an order from their cart's contents. Following this, customers can proceed to checkout and pay for their orders using a secure payment gateway integrated within this container.
3. **Order History Viewing:** To assist customers in keeping track of their previous purchases, this container provides functionality for accessing a history of past orders.
4. **Cart Visibility:** Customers can view their cart at any time, allowing them to keep an eye on all the products they are about to purchase, ensuring a smoother shopping experience.
Overall, the "cart_and_order_management" container is designed to streamline the shopping and purchasing process, enhancing the customer's journey from product selection to successful checkout with a secure payment system. It plays a vital role in ensuring seamless transactions and effective order tracking within the E-Farmers platform.
### PERSISTANCE EVALUATION
The "cart_and_order_management" container requires data storage to fulfill its purpose and user stories effectively. Specifically, it needs to store:
- **Cart Data:** Temporarily store the unique product identifiers for items added to a customer's cart, along with quantities.
- **Order Data:** Permanently store details of generated orders, including order IDs, timestamps, customer IDs, product IDs, quantities, payment status, and transaction IDs.
- **Order History:** Maintain historical order data for customers to access or review past purchases.
### EXTERNAL SERVICES CONNECTIONS
Based on the container's purpose and user stories, the container will need to connect to several external services:
- **Payment Gateway:** Integration with a secure external payment service to process transactions during the checkout phase. This could be services like Stripe, PayPal, or another similar platform to manage payments securely.
- **User Management Service:** Communication with the "user_management" container to validate user sessions and track which customer is making the cart modifications or placing orders.
These services are essential to ensure secure and efficient operation of the shopping cart and order management processes.
### MICROSERVICES:
#### MICROSERVICE: cart_management
- TYPE: backend
- DESCRIPTION: Handles operations related to managing the shopping cart. Enables customers to add, view, and delete items, as well as manage cart contents and view cart at any given time.
- PORTS: 10800
- TECHNOLOGICAL SPECIFICATION
The "cart_and_order_management" container will be primarily developed using Node.js with the Express framework for building scalable and efficient RESTful APIs. For database interactions, MongoDB is an appropriate choice given its flexibility in handling a diverse range of cart and order data with its document-oriented storage. Additionally, Mongoose, a MongoDB object modeling tool, can be used for data validation and structured queries. For secure payment handling, the Stripe Node.js library can be leveraged, supporting secure communication with payment gateways. Other libraries such as JWT can be used for secure user session management and authentication, especially when interfacing with the user management service.
- SERVICE ARCHITECTURE
The architecture of the "cart_and_order_management" container adopts several microservices patterns to promote modularity, scalability, and maintainability. The microservices are designed to follow the principle of separation of concerns, where each microservice tackles a distinct functional area of the platform:
- The **cart_management** microservice employs the Repository pattern for efficient access and management of cart data. It exposes RESTful endpoints for cart operations like adding, viewing, and deleting items.
- The **order_processing** microservice utilizes the Transactional Outbox pattern to handle the creation and processing of orders, ensuring eventual consistency especially with connector operations to external payment gateways.
- The **payment_integration** microservice is built upon the API Gateway pattern, abstracting the complexity of integrations with external payment services and ensuring secure endpoints for payment processing.
- The **order_history** microservice utilizes the Event Sourcing pattern to store and retrieve comprehensive historical order data. This approach allows it to keep a reliable audit log of user activity related to order placements.
- The **database** microservice leverages the CQRS (Command Query Responsibility Segregation) pattern, maintaining separate models for updating data (commands) and reading data (queries) to optimize performance.
In terms of service communication, services use asynchronous messaging for non-blocking interactions, especially when transitioning between cart checkout and order processing. This ensures system resilience and seamless user experiences.
- ENDPOINTS
HTTP Method	Endpoint URL	Description	User Stories
POST	/cart/add	Add a product to the customer's shopping cart, updating the cart with the new item.	14
DELETE	/cart/delete	Delete items from the customer's shopping cart to allow changes in the selection.	15
GET	/cart/view	View the current contents of the customer's shopping cart.	33
POST	/order/create	Generate an order with the items currently in the cart for the customer.	16
POST	/order/checkout	Facilitate the checkout process by connecting with a secure payment gateway for order payment.	17
GET	/order/history	Retrieve a list of past orders for the customer to track their purchase history.	22

#### MICROSERVICE: order_processing
- TYPE: backend
- DESCRIPTION: Facilitates the generation and processing of orders from the shopping cart. Manages order creation, payment processing through an external payment gateway, and updates order status.
- PORTS: 10810
- TECHNOLOGICAL SPECIFICATION
The "cart_and_order_management" container employs a combination of technologies suited to handle backend operations, database management, and secure middleware communication.
1. **Backend Microservices (cart_management, order_processing, order_history):** These microservices utilize the Python programming language with the Django framework due to its robust support for rapid development and clean architecture. Django REST framework is used to build RESTful APIs, which facilitates communication between these microservices and other components.
2. **Middleware Microservice (payment_integration):** Java with Spring Boot is chosen for this middleware service to handle secure communications with external payment gateways like Stripe or PayPal, ensuring reliable transaction processing and data integrity.
3. **Database Microservice:** PostgreSQL is selected as the database management system due to its reliability and support for complex queries, needed for cart data storage and historical order management.
- SERVICE ARCHITECTURE
The "cart_and_order_management" container's service architecture emphasizes modularity and integration, ensuring seamless communication and functionality across different microservices. The architectural patterns adopted include:
1. **Microservices Architecture:** Each service in the container is its own microservice, handling specific functionalities—cart management, order processing, payment integration, order history retrieval, and database operations. This allows for independent deployment and scaling.
2. **RESTful Services:** The backend microservices implement RESTful APIs, promoting stateless interactions and resource-based operations, ensuring separation of concerns and ease of use.
3. **Middleware Architecture:** The payment_integration microservice acts as middleware, ensuring secure communication with external payment gateways. The application of security measures such as OAuth 2.0 for authentication of payment services ensures secure transactions.
4. **Database Management Pattern:** The database microservice handles both temporary (cart) and permanent (order history) data storage, employing CRUD operations to manage the lifecycle of the data effectively.
5. **Integration Pattern:** Communication between container microservices is facilitated through API gateway or service mesh, ensuring streamlined data flow, service discovery, and monitoring. This pattern ensures scalability and manages inter-service communications efficiently.
6. **Event Sourcing for Order Processing:** Adopting event-driven architecture where changes in state (like order status updates) are recorded as a sequence of events, which aids in scalability and operational monitoring.
- ENDPOINTS
HTTP Method	Endpoint URL	Description	User Stories
POST	/cart/add	Add a product to the user's shopping cart, storing product identifiers and quantities temporarily.	14
DELETE	/cart/delete	Remove specific boxes or products from the user's shopping cart to allow modification of cart items.	15
GET	/cart/view	Retrieve and display the current contents of the user's shopping cart, showing product identifiers and quantities for review.	33
POST	/order/generate	Convert the contents of the user's shopping cart into an order, saving order details for further processing.	16
POST	/order/checkout	Process the user's order for payment using an integrated and secure payment gateway, updating payment status.	17
GET	/order/history	Retrieve the user's past orders from the order history for review, displaying details like order IDs and timestamps.	22

#### MICROSERVICE: payment_integration
- TYPE: middleware
- DESCRIPTION: Manages secure communication and transaction processing with an external payment gateway service. Ensures data integrity during payment operations.
- PORTS: 10820

#### MICROSERVICE: order_history
- TYPE: backend
- DESCRIPTION: Provides functionality to retrieve and display previous orders for a user, enabling them to track past purchases.
- PORTS: 10830
- TECHNOLOGICAL SPECIFICATION
The "order_history" microservice is implemented using Python with the Flask framework, which is known for its simplicity in building RESTful APIs. For data persistence, SQLAlchemy is used as an ORM (Object-Relational Mapping) library to interact with a PostgreSQL database, ensuring efficient data manipulation and retrieval. The service also leverages libraries such as Marshmallow for data serialization and deserialization, and Celery can be utilized for any asynchronous tasks, such as generating order history reports, although this might be scoped for future expansions depending on the operational plan.
- SERVICE ARCHITECTURE
The service architecture for the "order_history" microservice adopts the "Repository Pattern" for data persistence, which separates the logic that retrieves data and maps it to the entity domain. This pattern enhances the maintainability by isolating the system logic from data access details. Moreover, the "RESTful Service Pattern" is implemented, where HTTP methods are used to perform CRUD operations on resources effectively. The "Microservice Pattern" is inherently present, allowing independent scalability and development. Finally, the "Circuit Breaker Pattern" can be employed in the communication with the database, ensuring resilience and preventing cascading failures in the event of database outages or high latency scenarios.
- ENDPOINTS
HTTP Method	Endpoint URL	Description	User Stories
GET	/order_history	Retrieve a list of previous orders for the current user to allow a check of past purchases.	22

MICROSERVICE: database
- TYPE: database
- DESCRIPTION: Stores cart data temporarily and order data permanently. Maintains historical data for order history, including order details, timestamps, and payment statuses.
- PORTS: 10840


## CONTAINER NAME: calendar_and_subscription_management

### USER STORIES:
7) As a customer, I can check on calendar all seasonal foodstuff
18) As a customer, I want to book a product from the calendar
19) As a customer, I can subscribe to a farmer, so I will be notified for his every new insertion
20) As a customer, I want to have a list of the farmers that I am subscribed to
35) As a customer, I want to be able to unsubscribe from a farmer, so that I no longer receive notifications for his insertions
### PORTS: 11000:11100
### DESCRIPTION: 
The calendar_and_subscription_management container in the E-Farmers e-commerce platform is designed to facilitate the interaction between customers and farmers by focusing on calendar-based activities and subscription management. Its primary purpose is to provide customers with the ability to engage with seasonal food offerings and maintain active subscriptions to their preferred farmers.
Key functionalities include:
1. **Calendar Management**: Customers can view a calendar outlining all seasonal foodstuffs, allowing them to plan their purchases according to seasonal availability (User Story 7).
2. **Product Booking**: Customers can book specific products directly from the calendar, thereby ensuring they have access to desired seasonal items (User Story 18).
3. **Subscription Management**: This includes enabling customers to subscribe to farmers, ensuring they receive notifications whenever the subscribed farmers publish new insertions (User Stories 19 and 20). The container also allows customers to maintain an updated list of their subscriptions and gives them the ability to unsubscribe from farmers whenever they choose, thus managing the flow of notifications (User Story 35).
Overall, this container enhances the user experience by aligning purchasing behavior with the seasonal nature of farm products and by facilitating ongoing customer-farmer relationships through subscriptions.
### PERSISTANCE EVALUATION
The calendar_and_subscription_management container needs to store data to fulfill its user stories effectively. It will need to persist calendar data for seasonal foodstuffs, which includes information on product availability and relevant timelines (User Story 7). It will also require storage for booking details, including product ID, booking date, and customer information, to manage bookings directly from the calendar (User Story 18). For subscription management, this container will need to store the list of subscribed farmers for each customer, capturing data such as farmer ID and customer ID for each subscription. Additionally, it will maintain a record of subscriptions to manage notifications and the ability to unsubscribe (User Stories 19, 20, and 35). Overall, this data will be critical for delivering a seamless user experience.
### EXTERNAL SERVICES CONNECTIONS
The calendar_and_subscription_management container may benefit from connecting to an external notification service provider to deliver timely updates or alerts to customers when new insertions are published by farmers they are subscribed to. Such a service would ensure reliable and efficient delivery of notifications, keeping customers informed in real-time. Other than notifications, the container does not explicitly require connections to other external services to fulfill its primary functions of managing calendars and subscriptions.
### MICROSERVICES:
#### MICROSERVICE: calendar_service
- TYPE: backend
- DESCRIPTION: Handles displaying and managing calendar events for seasonal food offerings, allowing customers to plan purchases based on seasonal availability. Supports the booking of products directly from the calendar.
- PORTS: 11010
- TECHNOLOGICAL SPECIFICATION
The core microservices (`calendar_service`, `booking_service`, and `subscription_service`) within the `calendar_and_subscription_management` container will utilize a JavaScript runtime, specifically Node.js, due to its efficiency in creating scalable network applications, augmented by the Express framework to build RESTful APIs. The `subscription_database` will leverage a relational database system, such as PostgreSQL, known for its robustness in handling structured data and support for complex queries. Libraries such as Moment.js for managing calendar dates and times, Sequelize as an ORM for database interaction, and EventEmitter for handling subscription notifications within the Node.js environment are also recommended.
- SERVICE ARCHITECTURE
The `calendar_and_subscription_management` container follows a microservices architecture, ensuring modularity and scalability. The `calendar_service` adopts the Command-Query Responsibility Segregation (CQRS) pattern, separating read and update operations to optimize performance and scalability. The `booking_service` implements the Transaction Script pattern, dealing with business logic embedded within scripts to handle individual processes such as booking and confirmation. The `subscription_service` utilizes the Publish-Subscribe pattern to efficiently deal with notifications, where the service acts as the publisher notifying subscribers about new farmer insertions. For persistence, the `subscription_database` layer implements the Data Mapper pattern with ORM for mapping business objects to database tables, ensuring a clean separation of business logic and database interaction.
- ENDPOINTS
HTTP Method	Endpoint URL	Description	User Stories
GET	/calendar	Retrieve all seasonal foodstuffs and their availability as displayed on the calendar.	7
POST	/calendar/book	Book a specific product directly from the calendar using product and customer details.	18
POST	/subscription/subscribe	Subscribe to a specific farmer to receive notifications about new offerings.	19
GET	/subscription/list	Retrieve the list of farmers a customer is subscribed to.	20
DELETE	/subscription/unsubscribe	Unsubscribe from a specific farmer to stop receiving notifications.	35

#### MICROSERVICE: booking_service
- TYPE: backend
- DESCRIPTION: Manages the booking of products chosen by customers from the calendar. It records booking details such as product ID, booking date, and customer information.
- PORTS: 11020
- TECHNOLOGICAL SPECIFICATION
For the calendar_and_subscription_management container, a Java-based technology stack is recommended due to its scalability and robust handling of complex business logic. Specifically, Spring Boot will be used as the backend framework to build RESTful APIs for the microservices. The inclusion of the Spring Data JPA library will facilitate interaction with databases for persistence requirements. The calendar_service, booking_service, and subscription_service microservices will employ Java with Spring Boot, utilizing libraries such as Spring Security, for securing subscription interactions, and Lombok, for reducing boilerplate code. The messaging and notification functionalities can be enhanced with the use of Apache Kafka or RabbitMQ for asynchronous message passing. A MySQL or PostgreSQL database will serve as the storage solution for the subscription_database, ensuring reliable data storage and retrieval.
- SERVICE ARCHITECTURE
The service architecture adopts a microservices pattern, which divides the container's functionality into distinct services: calendar_service, booking_service, and subscription_service.
- The **calendar_service** will follow the Repository pattern to manage data access to the calendar events effectively. It will use REST for communication between its components and other microservices, exposing endpoints for calendar viewing and event booking functionalities.
- The **booking_service** will implement the Domain-Driven Design pattern to clearly define its operations around booking logic. It will also use the Event Sourcing pattern paired with an event bus for real-time updates on booking actions and changes.
- The **subscription_service** will incorporate a layered architecture pattern, consisting of a presentation layer for handling request-response logic, a business logic layer for subscription management, and a data access layer to interact with the subscription_database.
- The **subscription_database** adheres to the CQRS (Command Query Responsibility Segregation) pattern to optimize read and write operations, ensuring efficient subscription data handling and retrieval.
To facilitate notification services, the Event-Driven architecture pattern will be utilized across services, particularly within the subscription_service microservice. It will generate and publish events related to new farmer insertions. This design choice will ensure seamless integration with an external notification service while maintaining service autonomy.
- ENDPOINTS
HTTP Method	Endpoint URL	Description	User Stories
GET	/calendar/seasonal-foods	Retrieve a list of all seasonal food offerings, allowing customers to view and plan their purchases based on availability.	7
POST	/calendar/book-product	Allow customers to book a specific product directly from the calendar by providing product details and customer information.	18
POST	/subscription/subscribe	Enable customers to subscribe to a farmer, which will trigger notifications for every new insertion published by the farmer.	19
GET	/subscription/list	Retrieve a list of farmers to which the customer is currently subscribed, providing visibility into existing subscriptions.	20
DELETE	/subscription/unsubscribe	Allow customers to unsubscribe from a farmer, stopping notifications for new insertions from that farmer.	35

#### MICROSERVICE: subscription_service
- TYPE: backend
- DESCRIPTION: Manages customer subscriptions to farmers, enabling notification functionalities for any new insertions published by subscribed farmers. It also manages the list of subscribed farmers and allows customers to manage their subscriptions, including the option to unsubscribe.
- PORTS: 11030
- TECHNOLOGICAL SPECIFICATION
The `subscription_service`, which handles the subscription management features of the E-Farmers platform, will be developed using Python with the Flask framework. Flask is lightweight and well-suited for building RESTful APIs, making it ideal for the subscription functionalities. SQLAlchemy will be utilized as the Object-Relational Mapping (ORM) library to efficiently manage interactions with the subscription data stored in the `subscription_database`. For real-time notifications, integration with an external message-brokering service such as RabbitMQ or a service like Firebase Cloud Messaging (FCM) could be considered to efficiently handle notification workflows and ensure timely communication with users.
- SERVICE ARCHITECTURE
The `subscription_service` follows a microservices architecture pattern by isolating subscription-related functionalities. It employs the Repository pattern to abstract access to the subscription data stored in the `subscription_database`. This promotes separation of concerns and enhances the ability to swap out storage solutions with minimal impact on the application logic. An Event-Driven architecture pattern might be applied in combination with message-brokering, enabling the service to react to events such as new farmer insertions by notifying subscribed customers. Additionally, middleware components may be embedded to handle authentication and rate limiting, ensuring secure and optimal service performance.
- ENDPOINTS
HTTP Method	Endpoint URL	Description	User Stories
GET	/calendar/seasonal	Retrieve and display the calendar of all seasonal foodstuff for customer planning.	7
POST	/calendar/book	Allow customers to book a product directly from the calendar, storing booking details.	18
POST	/subscription/subscribe	Enable customers to subscribe to a farmer for receiving notifications about new insertions.	19
GET	/subscription/list	Retrieve a list of farmers that the customer is currently subscribed to.	20
DELETE	/subscription/unsubscribe	Allow customers to unsubscribe from a farmer to stop receiving notifications about new insertions.	35

#### MICROSERVICE: subscription_database
- TYPE: database
- DESCRIPTION: Stores subscription data for customers, including the list of subscribed farmers, along with necessary details like farmer ID and customer ID. The storage is used to manage notification flows and subscription lists.
- PORTS: 11040


## CONTAINER NAME: delivery_management

### USER STORIES:
25) As a rider, I want to have a personal delivery page
26) As a rider, I want to change my availability status to available so that I can receive delivery requests
27) As a customer, I want to select a delivery option, so that I can receive the products at home
34) As a rider, I want to be able to update the status of an order that I have delivered
### PORTS: 11200:11300
### DESCRIPTION: 
The delivery_management container is integral to the E-Farmers platform as it oversees the logistics of getting products from farmers to customers who cannot personally visit the farmer's warehouse. It is responsible for managing all delivery operations, ensuring that users can select delivery options, and facilitating the seamless distribution of products. Additionally, it caters to rider-specific functionalities, enabling riders to manage their delivery-related tasks efficiently. This includes allowing riders to have a dedicated personal delivery page, update their availability status to receive delivery requests, and update the status of orders they have delivered. By handling delivery requests and coordinating rider operations, this container ensures that the delivery process is smooth, timely, and reliable for all users on the platform. The delivery_management container thus plays a crucial role in bridging the gap between farmers and customers, ensuring that fresh, locally-sourced products reach the customer's doorstep conveniently.
### PERSISTANCE EVALUATION
The delivery_management container needs to store several key pieces of data to fulfill its purpose and user stories. It needs to maintain records of delivery requests, including customer details, order information, and delivery addresses. Additionally, it should store data regarding riders, such as their personal delivery page details and their availability status. It should also keep track of the status of each order, including updates provided by the riders once the delivery is completed. This information is crucial for managing logistics and ensuring successful deliveries.
### EXTERNAL SERVICES CONNECTIONS
The delivery_management container may need to connect to external services, such as map services or routing APIs, to provide accurate delivery route information and estimated delivery times. This would ensure efficient routing and could enhance the overall delivery process. Additionally, a connection to a messaging or notification service might be necessary to inform customers and riders about delivery updates and changes in delivery status.
### MICROSERVICES:
#### MICROSERVICE: delivery_operations_service
- TYPE: backend
- DESCRIPTION: This microservice handles the core delivery operations, including managing delivery requests, selecting delivery options, and coordinating with riders. It ensures products are delivered from farmers to customers by managing logistics efficiently
- PORTS: 11210
- TECHNOLOGICAL SPECIFICATION
The delivery_operations_service will be implemented using the Node.js runtime environment for its asynchronous, event-driven nature, which is ideal for handling I/O-bound operations like network requests. The Express.js framework will be used for building RESTful APIs to manage delivery operations with riders and customers. For storage and persistence, MongoDB will be used to handle the diverse delivery-related data, accommodating its scalability and flexibility with documents. The middleware microservices such as routing_service and notification_service will integrate with external APIs using libraries such as Axios for HTTP requests. To facilitate real-time updates and notifications, WebSockets or a library like Socket.io may be considered. Additionally, Docker will be used to containerize the service, ensuring it can be easily deployed and scaled.
- SERVICE ARCHITECTURE
The service adopts a microservices architecture pattern. Each microservice is dedicated to a specific business capability, promoting modularity and independence. The delivery_operations_service follows the API Gateway pattern to manage incoming requests and route them to the appropriate underlying service, whether related to delivery operations or rider management. This ensures decoupled and organized handling of operations. Additionally, the service architecture is designed around the Repository pattern for interacting with the persistence layer, separating the business logic from the database interaction. To ensure efficient communication, asynchronous message-passing is utilized, especially with the notification_service, relying on event-driven communication patterns to facilitate seamless updates across services. A Circuit Breaker pattern is employed in the routing_service to handle external API failures gracefully, promoting the resiliency of the delivery operations.
- ENDPOINTS
HTTP Method	Endpoint URL	Description	User Stories
GET	/delivery/options	Retrieve available delivery options for customers to choose from.	27
POST	/delivery/request	Create a delivery request with customer details and order information.	27
GET	/rider/deliveryPage	Fetch the personal delivery page for the rider to manage tasks.	25
PUT	/rider/availability	Update the rider's availability status to receive delivery requests.	26
POST	/delivery/status	Update the status of an order once it has been delivered by the rider.	34

#### MICROSERVICE: rider_management_service
- TYPE: backend
- DESCRIPTION: Responsible for rider-specific functionalities, such as managing personal delivery pages, updating rider availability status, and tracking the status of delivered orders. It enables riders to efficiently manage their delivery tasks.
- PORTS: 11220
- TECHNOLOGICAL SPECIFICATION
The rider_management_service microservice is best implemented using the Django framework with Python, given its powerful capabilities for developing complex backend services. Django REST framework can be incorporated to design and build RESTful APIs that the mobile app or web frontend components could consume. The framework's scalability and rich feature set make it suitable for handling rider-specific functionalities effectively. For data storage, PostgreSQL can be utilized due to its robustness and support for advanced data types. Integrating Celery can aid in managing asynchronous tasks, such as notifying riders of new delivery requests or handling status updates.
- SERVICE ARCHITECTURE
The rider_management_service microservice adopts a layered architectural pattern. It leverages the Model-View-Controller (MVC) design pattern, inherent to Django, to separate the business logic (managed by models), input and data processor (forms and views), and user interface (templates for APIs response).
- **Model Layer**: Represents the data structure, focusing on storing rider details, availability status, delivery page information, and order status logs. Interaction with the database is handled by Django’s ORM.
- **View Layer**: Implements the application workflow, handles requests from external clients, and returns appropriate responses. The views will define API endpoints such as changing availability status, fetching personal delivery page details, and updating the delivery status of an order.
- **Controller Layer**: Manages the communication between models and views, transforming data models into established structures suitable for the views to use.
- **Middleware Integration**: The middleware layer is crucial to interacting with external notification services to inform riders of new deliveries or status changes in requests they are managing.
The service guarantees seamless rider operation management by creating APIs that interact with other services, such as the delivery_operations_service and notification_service, ensuring collaboration across the container ecosystem.
- ENDPOINTS
HTTP Method	Endpoint URL	Description	User Stories
GET	/rider/profile	Retrieve the personal delivery page details for the rider, including delivery history and upcoming deliveries	25
POST	/rider/availability	Update the rider's availability status to receive delivery requests	26
POST	/rider/order/update	Allow the rider to update the status of an order they have completed, logging the delivery and notifying stakeholders	34
GET	/rider/availability	Fetch the current availability status of a rider to check if they can receive new delivery requests	26

#### MICROSERVICE: delivery_persistence
- TYPE: database
- DESCRIPTION: Stores delivery-related data, such as delivery requests, customer details, rider information, and order status updates. It is essential for tracking and managing logistics effectively.
- PORTS: 11230

#### MICROSERVICE: routing_service
- TYPE: middleware
- DESCRIPTION: Interfaces with external mapping or routing APIs to provide accurate delivery route information and estimated delivery times. It optimizes delivery efficiency by ensuring accurate routing.
- PORTS: 11240

#### MICROSERVICE: notification_service
- TYPE: middleware
- DESCRIPTION: Connects with external messaging or notification services to inform customers and riders about delivery updates and the status of delivery requests. It maintains communication flow for all stakeholders during the delivery process.
- PORTS: 11250


## CONTAINER NAME: notification_and_feedback

### USER STORIES:
23) As a user that bought a box, I want to leave a comment to the farmer
28) As a farmer, I want to earn badges so that my achievements are showcased on my profile page
32) As a user, I want to see the status of my requests for booked boxes
36) As a customer, I want to have a notification center, so I can read my notifications
### PORTS: 11400:11500
### DESCRIPTION: 
The notification_and_feedback container is pivotal for enhancing user engagement and satisfaction on the E-Farmers platform. This container is responsible for managing notifications and facilitating feedback mechanisms between users and farmers.
Firstly, it implements a notification center, providing customers with updates about events or changes related to their interactions on the platform. This functionality is crucial for maintaining user engagement and ensuring that customers are promptly informed about important events, such as order status updates or new insertions by subscribed farmers.
Secondly, this container enables the feedback system, allowing users who have purchased products to leave comments for farmers. This feature is important for building trust and transparency on the platform, as it allows honest reviews which can help other customers make informed purchasing decisions.
Moreover, the container manages a system of badges that farmers can earn, showcasing their achievements on their profile pages. This gamification element can motivate farmers to enhance their performance and customer service, as well as serve as a marker of reputation for potential customers.
Finally, it provides users with information about the status of their requests for booked products, ensuring they are informed and can plan accordingly, thus contributing to an overall positive user experience.
Overall, the notification_and_feedback container enhances the interactivity and reliability of the platform, contributing to a vibrant community of informed and engaged users.
### PERSISTANCE EVALUATION
The notification_and_feedback container needs to store various types of data to fulfill its purpose and user stories. It needs to store notifications related to user interactions and platform updates to provide a comprehensive notification center. Feedback data, including user comments and ratings for farmers, should also be stored, allowing for transparency and customer engagement. Additionally, the container should maintain a record of badges earned by farmers, showcasing their achievements. Furthermore, it needs to track the status of user's requests for booked products to keep users updated accurately.
### EXTERNAL SERVICES CONNECTIONS
Based on its purpose and user stories, the notification_and_feedback container doesn't inherently require connections to external services. However, if push notifications are required for real-time updates, it might need to connect to an external push notification service such as Firebase Cloud Messaging or Apple Push Notification Service. Also, for advanced feedback analysis or language processing, integration with services offering sentiment analysis or natural language processing might be considered in the future.
### MICROSERVICES:
#### MICROSERVICE: notification_center
- TYPE: backend
- DESCRIPTION: This microservice manages the notification system for the E-Farmers platform. It stores and handles all notifications related to user interactions, order updates, and new insertions by subscribed farmers, ensuring users are consistently and promptly informed.
- PORTS: 11410
- TECHNOLOGICAL SPECIFICATION
The notification_center microservice will utilize Node.js as the primary programming language, leveraging its asynchronous capabilities to handle real-time notifications effectively. To build robust RESTful APIs, the Express framework will be employed. This stack will support high throughput and maintainability. For real-time features, libraries such as Socket.io may be considered if push notifications are to be implemented internally. For data persistence, a NoSQL database like MongoDB might be used to efficiently handle unstructured data such as notifications and feedback. Moreover, should integration with an external push notification service be required, the Firebase Admin SDK or Node.js libraries for Apple Push Notification Service can be considered.
- SERVICE ARCHITECTURE
The notification_center microservice will adopt a modular architecture utilizing the Controller-Service-Repository pattern. This pattern ensures a clear separation of concerns with Controllers to handle HTTP requests, Services to encapsulate business logic, and Repositories to manage data persistence and retrieval from the database. The system will employ a Pub/Sub pattern to decouple the notification producer and consumer, allowing for the potential integration of real-time messaging systems like WebSockets or external services. Modularization will allow easy scaling of individual components as needed, maintaining the system's responsiveness and ensuring high reliability in managing user notifications and feedback mechanisms.
- ENDPOINTS
HTTP Method	Endpoint URL	Description	User Stories
POST	/notifications/subscribe	Subscribe a user to updates from a specific farmer or category for ongoing notifications.	36
GET	/notifications	Retrieve all notifications for a user, providing updates on order status, new insertions, and other relevant events.	36
POST	/feedback	Submit a comment and rating for a farmer after purchasing a box, contributing to transparency and trust.	23
GET	/feedback/{farmer_id}	Fetch all feedback and ratings for a specified farmer to help users make informed purchasing decisions.	23
GET	/badges	List all badges available on the platform that farmers can earn and showcase.	28
GET	/badges/{farmer_id}	Retrieve all badges earned by a specific farmer to display their achievements on their profile.	28
GET	/requests/status	Provide the current status of a user's requests for booked products, aiding in planning and management.	32

#### MICROSERVICE: feedback_system
- TYPE: backend
- DESCRIPTION: The feedback system microservice enables users to leave comments and ratings for farmers after purchasing their products. It stores feedback data, allowing for transparent reviews that help build trust between users and farmers on the platform.
- PORTS: 11420
- TECHNOLOGICAL SPECIFICATION
The notification_and_feedback container consists of several backend microservices and will benefit from a tech stack that allows for efficient management of asynchronous operations and provides scalability. Thus, Node.js is chosen as the primary programming language due to its non-blocking, event-driven architecture, which is well-suited for handling I/O-bound operations like interacting with databases for notifications and feedback.
For the framework, Express.js will be used to structure the API development. Key libraries to include would be Mongoose for MongoDB interactions, owing to its BSON-style storage ideally suited for the JSON-like data required for notifications, feedback, and badges. Additional libraries include Socket.io for implementing real-time notifications, and if push notifications are considered, Firebase Admin SDK could be integrated. JWT (JSON Web Token) is also recommended for ensuring user verification during requests.
- SERVICE ARCHITECTURE
The service architecture will adopt a microservices pattern, where individual logical units are divided into separate services:
1. **Notification Center**: This microservice will follow the Observer design pattern, allowing actions in other parts of the platform to trigger notification events. It will use websockets via Socket.io for real-time updates and can be extended with provider-agnostic push notifications modules for additional reach.
2. **Feedback System**: This will employ a RESTful API pattern to handle user feedback submission and retrieval, ensuring standard operations like Create, Read, Update, and Delete (CRUD) can be efficiently managed. It includes validation layers to ensure integrity and appropriateness of comments.
3. **Badge Management**: To handle badge assignments, this microservice will use a State pattern to manage the state changes of farmer profiles as badges are earned. A rule-engine could be integrated to automatically assess achievements and update badge status
4. **Request Status Tracker**: This service will be structured using a Scheduler-Queue pattern, which regularly tracks status changes in requests and updates users accordingly. It also leverages the Polling pattern to provide real-time updates on user requests
The microservices will communicate over HTTP REST for synchronous operations and through message queuing for asynchronous operations using a tool like RabbitMQ or Apache Kafka to minimize coupling and ensure scalability. Each microservice will be containerized using Docker to encapsulate dependencies and streamline deployment across different environments.
- ENDPOINTS
HTTP Method	Endpoint URL	Description	User Stories
GET	/feedback/comments	Retrieve comments left by users who have purchased products from farmers.	23
POST	/feedback/comments	Allow users to leave comments and ratings for farmers after purchasing their products.	23
GET	/badge/achievements	Retrieve a list of badges earned by farmers, showcasing their achievements on their profile page.	28
POST	/badge/earn	Assign badges to farmers based on their achievements, helping to motivate and showcase their performance.	28
GET	/request/status	Provide users with information about the status of their requests for booked products, ensuring they are well-informed.	32
GET	/notifications	Retrieve notifications related to user interactions, order updates, and platform changes, allowing users to stay informed.	36

#### MICROSERVICE: badge_management
- TYPE: backend
- DESCRIPTION: This microservice handles the badge system for farmers, showcasing achievements on their profile pages. It tracks and stores badges earned by farmers as a gamification element and a reputation marker to encourage better performance.
- PORTS: 11430

#### MICROSERVICE: request_status_tracker
- TYPE: backend
- DESCRIPTION: The request status tracker microservice provides users with information about the status of their requests for booked products. It stores and updates the status, ensuring users can stay informed and better plan their actions related to bookings.
- PORTS: 11440
- TECHNOLOGICAL SPECIFICATION
The microservice `request_status_tracker` can be developed using Python along with the Flask framework for building RESTful APIs. Flask offers a lightweight and flexible framework that can efficiently handle the specific requirements of this microservice. For database interactions, SQLAlchemy can be employed as an ORM to facilitate robust and scalable data operations. Messaging and notifications within the platform could leverage RabbitMQ or Apache Kafka for efficient message brokering, if real-time updates are incorporated. Given that this microservice might handle several asynchronous tasks, Celery can be used for task queue management. If there is a need for enhanced observing tools, Prometheus for monitoring and Grafana for visualization can be integrated.
- SERVICE ARCHITECTURE
The `request_status_tracker` microservice adopts a microservices architecture pattern, with a focus on modular and independent service deployment. The service implements the following patterns:
1. **Microservices Pattern**: The microservice is independently deployable and designed to perform a specific function, focusing on updating and retrieving request statuses efficiently without interfering with other services.
2. **Repository Pattern**: For managing data CRUD operations. This pattern keeps the data access layer separated from the application logic, enhancing maintainability and scalability of the microservice.
3. **Event-Driven Pattern**: If push notifications are required, this microservice can use an event-driven architecture to provide real-time updates via an asynchronous messaging service like RabbitMQ or Kafka.
4. **Circuit Breaker Pattern**: Implemented to handle potential failures in dependent services and improve resiliency. This ensures that a failure in one service does not cascade down to impact the entire system.
5. **API Gateway Pattern**: If applicable, an API Gateway can be employed to handle all ingress traffic, streamlining communication and potential security concerns by routing requests to the appropriate microservice.
6. **Service Discovery**: Tools like Consul or etcd may be included for service registration and discovery, ensuring dynamic routing of requests and reliable inter-service interaction.
These architectural strategies ensure a responsive, scalable, and resilient service that aligns with contemporary microservices best practices.
- ENDPOINTS
HTTP Method	Endpoint URL	Description	User Stories
GET	/request_status/{requestId}	Retrieve the status of a specific request using the request ID, allowing users to stay informed about their booked products' progress.	32
PATCH	/request_status/{requestId}	Update the status of a specific request, ensuring users have current information about their booked products.	32

## CONTAINER NAME: frontend

### PORTS: 11600:11700
### DESCRIPTION: 
The frontend container is responsible for hosting and delivering the user-facing application of the E-Farmers e-commerce website. Its purpose is to provide a seamless and interactive interface for users, including visitors, customers, farmers, and riders, allowing them to navigate the platform efficiently. The container will house the user interface components and communicate with backend services to perform tasks like user registration, product insertion management, search functionality, order processing, and more. By offering an intuitive and responsive design, the frontend container aims to enhance user experience, facilitate ease of use, and ensure that all user functionalities are accessible across various devices and platforms.
### PERSISTANCE EVALUATION
The frontend container does not require long-term data storage to fulfill its purpose and user stories. Instead, it relies on backend services to access and manipulate data. It may use browser-side techniques such as cookies or local storage to temporarily store user session details for enhancing user experience, but these are managed within the user's browser rather than being persisted within the container itself.
### EXTERNAL SERVICES CONNECTIONS
The frontend container primarily interfaces with internal backend services to provide dynamic content and facilitate interactions such as user registration, search functionalities, and order processing. However, for certain features like OAuth login (User story 29), it may connect to external authentication providers (e.g., Google, Facebook) to streamline the login process. This connection is necessary for supporting third-party authentication and ensuring a smooth and secure login experience for users opting for OAuth registration.
### MICROSERVICES:
#### MICROSERVICE: frontend
- TYPE: frontend
- DESCRIPTION: This microservice hosts and delivers the user-facing application of the E-Farmers e-commerce website. It provides a seamless and interactive interface for users including visitors, customers, farmers, and riders. The microservice is responsible for navigating through the platform, showcasing available functionalities, and facilitating interactions with the backend services to handle user registration, product insertions, searches, order processing, and more. Its design ensures responsiveness and accessibility across different devices and platforms.
- PORTS: 11600
- TECHNOLOGICAL SPECIFICATION
For the frontend microservice of the E-Farmers e-commerce platform, the technological stack should focus on building responsive, dynamic, and interactive user interfaces. ReactJS is a suitable choice as the main JavaScript library for building user interfaces due to its component-based architecture and ability to efficiently render views in response to data changes. Additionally, a front-end application bundler like Webpack or ViteJS can be used for optimal resource management and development convenience. Styling can be managed using CSS-in-JS libraries such as styled-components or Emotion, which allow for scoped styling and dynamic theme management. For seamless and consistent design across the application, UI frameworks such as Material-UI or Ant Design can be integrated. As for making HTTP requests to the backend services, the axios library can be employed for ease of use and robust handling of API calls.
- SERVICE ARCHITECTURE
The architecture of the frontend microservice is structured around a single-page application (SPA) pattern, facilitating a highly interactive and seamless browsing experience. The component-based architecture of React allows for modular and maintainable code with reusable components representing different application features. The application state management can be handled using React Context API or Redux to allow for efficient data flow and state management across components. For routing, React Router can be utilized to manage dynamic client-side navigation effectively, enabling the application to update the view without requiring page reloads. Integration with external services for OAuth login is managed via Context Providers and dedicated components to initiate and handle authentication processes securely. The application will leverage responsive design principles to ensure it is accessible across various devices and screen sizes, keeping user experience coherent and intuitive.
- PAGES
Page Name	Description	User Stories
Homepage	Displays the main landing page of the E-Farmers e-commerce website, showcasing featured products and navigation links.	N/A
ProductList	Shows the available products for browsing and searching, with options to filter and sort.	N/A
ProductDetail/<id>	Displays detailed information about a specific product, including images, descriptions, and purchase options.	N/A
UserRegistration	Handles user registration, allowing new users to create an account on the platform.	N/A
UserLogin	Facilitates user login, including support for OAuth login through external providers.	29
UserProfile	Displays user profile information and allows for updates and management of personal details.	N/A
Cart	Shows the user's shopping cart with options to modify item quantities and proceed to checkout.	N/A
Checkout	Handles the checkout process, collecting user shipping and payment information for order processing.	N/A
OrderHistory	Displays a list of past purchases with details on each order.	N/A
ContactUs	Provides a form for users to contact customer support with inquiries or issues.	N/A